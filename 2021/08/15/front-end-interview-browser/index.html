<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="sticla"><meta name="copyright" content="sticla"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>备战前端面试--浏览器和V8引擎篇 | sticla studio</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#6200ee"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"blog.sticla.top","root":"/","title":"sticla studio","version":"1.5.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-CCS65Z3P4C"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-CCS65Z3P4C');
}</script><meta name="description" content="备战前端面试–浏览器和V8引擎篇V8 引擎内存机制考点1：数据存储 JavaScript 中的数据类型是如何存储的？ 在 JavaScript 中，数据的基本存储方式有两种：栈存储和堆存储，而变量的存储位置是不固定的。 一般情况下，基本数据类型，其值比较简单，存储在栈空间。 具体而言，以下数据类型存储在栈中:  boolean null undefined number string symbol">
<meta property="og:type" content="article">
<meta property="og:title" content="备战前端面试--浏览器和V8引擎篇">
<meta property="og:url" content="https://blog.sticla.top/2021/08/15/front-end-interview-browser/index.html">
<meta property="og:site_name" content="sticla studio">
<meta property="og:description" content="备战前端面试–浏览器和V8引擎篇V8 引擎内存机制考点1：数据存储 JavaScript 中的数据类型是如何存储的？ 在 JavaScript 中，数据的基本存储方式有两种：栈存储和堆存储，而变量的存储位置是不固定的。 一般情况下，基本数据类型，其值比较简单，存储在栈空间。 具体而言，以下数据类型存储在栈中:  boolean null undefined number string symbol">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/li-sticla/picBed@latest/image-20210912033219763.png">
<meta property="article:published_time" content="2021-08-15T19:07:32.000Z">
<meta property="article:modified_time" content="2023-02-02T06:23:29.266Z">
<meta property="article:author" content="sticla">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="浏览器">
<meta property="article:tag" content="Google V8">
<meta property="article:tag" content="NodeJS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/li-sticla/picBed@latest/image-20210912033219763.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="sticla"><img width="96" loading="lazy" src="https://cdn.jsdelivr.net/gh/li-sticla/picBed@latest/EAXX2-BUwAA2FuM (2).jpg" alt="sticla"><span class="site-author-status" title="我爱摸鱼">😭</span></a><div class="site-author-name"><a href="/about/">sticla</a></div><span class="site-name">sticla studio</span><sub class="site-subtitle">Change the world！</sub><div class="site-desciption">只有弱者才睡觉！</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">20</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/li-sticla" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:yuanzichao@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1619244804" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/5050630" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/sticla_yuuri" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/sticla" title="Telegram" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E6%88%98%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%93%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8CV8%E5%BC%95%E6%93%8E%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">备战前端面试–浏览器和V8引擎篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#V8-%E5%BC%95%E6%93%8E"><span class="toc-number">1.1.</span> <span class="toc-text">V8 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">内存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">考点1：数据存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6-GC"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">考点2：内存回收 GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9Av8-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">考点1：v8 执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9AJS-%E7%9A%84%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">考点1：JS 的宏任务与微任务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS"><span class="toc-number">1.2.</span> <span class="toc-text">NodeJS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9ANodeJS-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">考点1：NodeJS 的事件循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">考点1：浏览器的事件循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.2.</span> <span class="toc-text">浏览器请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BD%91%E7%BB%9C"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">考点1：页面加载与网络</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">浏览器存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">考点1：浏览器存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">考点2：浏览器缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">浏览器渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E9%A1%B5%E9%9D%A2%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">考点1：页面解析渲染过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">考点2：回流重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B93%EF%BC%9A%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%B7%E6%96%B0"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">考点3：渲染与刷新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">浏览器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">考点1：同源策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">考点2：跨域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B93%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%BB%E5%87%BB"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">考点3：浏览器攻击</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://blog.sticla.top/2021/08/15/front-end-interview-browser/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sticla"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="sticla studio"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">备战前端面试--浏览器和V8引擎篇</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-08-15 19:07:32" itemprop="dateCreated datePublished" datetime="2021-08-15T19:07:32+00:00">2021-08-15</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2023-02-02 06:23:29" itemprop="dateModified" datetime="2023-02-02T06:23:29+00:00">2023-02-02</time></div><span class="leancloud_visitors" id="/2021/08/15/front-end-interview-browser/" data-flag-title="备战前端面试--浏览器和V8引擎篇"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%AD%A6%E4%B9%A0-JavaScript/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习-JavaScript</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/JavaScript/" style="--text-color:#F4DF4F"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">JavaScript</span></a><a class="tag" href="/tags/interview/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">interview</span></a><a class="tag" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">浏览器</span></a><a class="tag" href="/tags/Google-V8/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Google V8</span></a><a class="tag" href="/tags/NodeJS/" style="--text-color:#026E00"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">NodeJS</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/429930d44169a040b9b3a3e187e2f63e?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">sticla</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#6200ee;"><h1 id="备战前端面试–浏览器和V8引擎篇"><a href="#备战前端面试–浏览器和V8引擎篇" class="headerlink" title="备战前端面试–浏览器和V8引擎篇"></a>备战前端面试–浏览器和V8引擎篇</h1><h2 id="V8-引擎"><a href="#V8-引擎" class="headerlink" title="V8 引擎"></a>V8 引擎</h2><h3 id="内存机制"><a href="#内存机制" class="headerlink" title="内存机制"></a>内存机制</h3><h4 id="考点1：数据存储"><a href="#考点1：数据存储" class="headerlink" title="考点1：数据存储"></a>考点1：数据存储</h4><ol>
<li><p><strong>JavaScript 中的数据类型是如何存储的？</strong></p>
<p>在 JavaScript 中，数据的基本存储方式有两种：栈存储和堆存储，而变量的存储位置是不固定的。</p>
<p>一般情况下，基本数据类型，其值比较简单，存储在栈空间。</p>
<p>具体而言，以下数据类型存储在栈中:</p>
<ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
<li>bigint</li>
</ul>
<p>对于<code>赋值</code>操作，原始类型的数据被完整地复制给变量的值。</p>
<p>对象数据类型的数据，其值通常比较复杂，因而创建的成本也很大，这类数据存储在堆空间中。在堆中，每个对象数据都有一个唯一的引用地址，通过该地址指向这个数据。</p>
<p>对于<code>赋值</code>操作，对象类型的数据的引用地址被复制给变量的值。</p>
<p><strong>对于栈来说，其功能除了保存数据，还有创建并切换执行上下文</strong>。</p>
<p>比如：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>具体执行时，在系统栈中的流程是：</p>
<ol>
<li>创建 func 函数执行上下文，压入栈顶。</li>
<li>执行 func，调用 f 函数，创建 f 函数执行上下文，栈顶指针上移，栈顶变为 f 函数执行上下文。</li>
<li>f 函数执行完毕，栈顶指针下移，其上下文在执行栈中销毁。</li>
<li>func 函数执行完毕，栈顶指针下移，其上下文在执行栈中销毁。栈顶变为全局执行上下文。</li>
</ol>
<p>因此如果采用栈来存储相对基本类型更加复杂的对象数据，那么切换上下文的开销将变得巨大。</p>
<p><strong>在这个基础上再深入一点，我们可以窥见闭包的本质：</strong></p>
<p>实际上所有函数都有闭包(闭包保存了上层上下文的数据，可以看成是上一个执行上下文的副本，然后函数将其作为私有属性 <code>closure</code>，通过这个属性可以指向闭包中的数据)。因此，闭包和引用类型同理，应当是保存在堆中的(如果是在栈中，随着函数上下文的销毁，下一次函数调用时将无法访问)，在函数中访问闭包内的变量，其实是通过引用地址指向闭包变量所在的空间(所以闭包也能像作用域链一样往上查找数据)。</p>
<p>可以试试看，证明在每个函数内部都有闭包的存在：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">debugger</span>
  a <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">debugger</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/li-sticla/picBed@latest/image-20210912033219763.png" alt="image-20210912033219763" loading="lazy"><strong>闭包甚至可以不是函数(这里是全局执行上下文对象)</strong></p>
<p>闭包默认是不可见的(没有引用就不创建)，只有存在指向父作用域的引用时才能看到。和引用类型一样，除非引用闭包的变量释放，否则闭包将一直占用内存。</p>
<p>关于闭包与对象之间的联系，MDN 也说得很清楚：</p>
<blockquote>
<p>A closure lets you associate some data (the environment) with a function that operates on that data. This has obvious parallels to object oriented programming, where objects allow us to associate some data (the object’s properties) with one or more methods.</p>
<p>Consequently, you can use a closure anywhere that you might normally use an object with only a single method.</p>
<p>闭包允许您将某些数据（环境）与对该数据进行操作的函数相关联。 这与面向对象编程有明显的相似之处，其中对象允许我们将一些数据（对象的属性）与一个或多个方法相关联。</p>
<p>因此，您可以在通常仅使用单个方法使用对象的任何地方使用闭包。</p>
</blockquote>
</li>
</ol>
<h4 id="考点2：内存回收-GC"><a href="#考点2：内存回收-GC" class="headerlink" title="考点2：内存回收 GC"></a>考点2：内存回收 GC</h4><ol>
<li><p><strong>V8 引擎如何进行垃圾内存的回收？</strong></p>
<p>对于栈的内存空间，只保存简单数据类型的内存，由操作系统自动分配和自动释放，而堆空间中的内存，需要由JS引擎手动释放。</p>
</li>
<li><p><strong>说说 V8 引擎的垃圾回收算法？</strong></p>
<p>绝大部分的对象生命周期都很短，大部分在经过一次垃圾回收后就释放掉。只有少数对象生命周期很长，一直是活跃的对象，v8 引擎为了提高回收效率，将堆内存分为两部分处理：<strong>新生代内存</strong>和<strong>老生代内存</strong>。</p>
<p>新生代内存是临时创建的内存空间，一般是 1 - 8 MB的容量，很快就会释放掉。而老生代内存容量要大很多。</p>
<p>针对两种不同的内存空间，v8 引擎执行不同的垃圾回收算法。</p>
<ol>
<li><p><strong>新生代垃圾回收</strong>：</p>
<p>对象在创建时都是先放在新生代内存中。大部分对象的存活时间很短，因此需要一个非常高效的算法。主要的算法是 <code>Scavenge</code>(清道夫)。它是一个典型的空间换时间的算法，通过将当前的堆内存一分为二，处于使用状态的空间称为<strong>from 空间</strong>，而闲置状态的空间称为 <strong>to空间</strong>。初始时对象都在 from 空间，当开始垃圾回收时，会把仍然活跃的对象复制放入 to 空间，并重新整理 from 空间，释放掉这部分内存。完成复制后，把 from 空间和 to 空间进行置换。</p>
<p>经过多次垃圾回收后仍然处于 from 空间的对象，在满足一定条件后(to 空间已使用超过 25%)会被移动到老生代内存中，这个过程叫做晋升。</p>
</li>
<li><p><strong>老生代垃圾回收：</strong></p>
<p>老生代内存中采用的是 <code>Mark-Compact</code>(标记整理)和 <code>Mark-Sweep</code>( 标记清除)算法。</p>
<p>标记清理过程分两段，由于老生代内存中活动对象占多数，所以在标记了非活动对象之后，直接将其清除。但是还存在一个问题，被清除的对象在内存中遍布各个地址，产生了很多内存碎片。若不清理这些碎片，那么在老生代内存中如果新增一个大对象，这时所有的碎片空间都不足以分配，会直接将其垃圾回收，而这是不必要的。</p>
<p>因此，在标记清理过程中，多了一个标记整理的过程。在此阶段，活动对象将会被移动到一端，然后再清理边界外的内存。</p>
</li>
</ol>
</li>
<li><p><strong>在 v8 垃圾回收过程中为什么需要增量标记？</strong></p>
<p>由于 JS 的单线程机制，v8 引擎在执行垃圾回收算法的时候务必会影响到业务逻辑的执行，这将导致线程阻塞。如果老生代内存的回收任务很重，耗时会很大，极度影响性能。在这种情况下， v8 采用增量标记的方案，将主任务拆分为许多小任务，让其穿插在 JS 应用逻辑的执行过程中。每个任务都有 5 - 10 ms 的停顿。</p>
</li>
</ol>
<h3 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h3><h4 id="考点1：v8-执行过程"><a href="#考点1：v8-执行过程" class="headerlink" title="考点1：v8 执行过程"></a>考点1：v8 执行过程</h4><ol>
<li><strong>v8 是怎么执行一段代码的？</strong></li>
</ol>
<p>初始化基础环境后，v8 引擎编译 JavaScript 代码，用解析器(parser)生成抽象语法树 AST。生成 AST 后，解释器根据 AST 生成对应的字节码(Byte Code)。优化编译器(TurboFan)将字节码进行优化，生成可被机器识别的机器码(Machine Code)。</p>
<p>可概括为以下过程：</p>
<ol>
<li><p>准备 JavaScript 的运行时环境</p>
</li>
<li><p>编译解析 JavaScript 代码，生成 AST 语法树</p>
</li>
<li><p>解释器根据 AST 生成对应的字节码</p>
</li>
<li><p>解释器解释执行字节码</p>
</li>
<li><p>监视器监听热点代码</p>
</li>
<li><p>基线编译器把热点代码优化为二进制机器码</p>
</li>
<li><p>优化编译器把二进制机器码再优化</p>
</li>
<li><p><strong>v8 的即时编译 JIT 是什么？</strong></p>
<p>v8 的运行时编译机制。v8 引擎在执行期间进行编译，而不是在代码运行之前。</p>
<p>解释器虽然简单，启动快，但是其执行效率很低，因为每次执行都是重新解析代码。而编译器虽然启动慢，但是在经过一次编译以后，再次运行相同的代码，就不必再进行一次重复的过程，因此执行快。</p>
<p>即时编译器尝试将解释器和编译器的优点结合，基本思想是避免重复转换。在解释器执行完一段代码后，其中的热点代码会被送到基线编译器中编译为二进制机器码，再次运行同样的代码，会被直接复用。而同时这些热点代码也会被送到优化编译器。优化编译器使用解释器收集的信息进行假设，并基于这些假设进行优化。</p>
</li>
</ol>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="考点1：JS-的宏任务与微任务"><a href="#考点1：JS-的宏任务与微任务" class="headerlink" title="考点1：JS 的宏任务与微任务"></a>考点1：JS 的宏任务与微任务</h4><ol>
<li><p><strong>什么是宏任务？</strong></p>
<p>JS 是单线程 EventLoop 机制，大部分的任务都在主线程上执行。为了让这些任务有条不絮地进行，需要有一个确定执行顺序的机制。V8 采用的是以队列的方式存储这些任务，先进入的先执行：</p>
<pre class="language-js" data-language="js"><code class="language-js">bool keep_running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">MainTherad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//执行队列中的任务</span>
    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//执行延迟队列中的任务</span>
    <span class="token function">ProcessDelayTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">//如果设置了退出标志，那么直接退出线程循环</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span> 
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>将队列中的任务一一取出，然后执行。队列包括普通任务队列和延迟任务队列(<code>setTimeout/setInterval</code> 这样的定时器回调任务)。</p>
<p>普通任务队列和延迟队列中的任务，都属于<strong>宏任务</strong>。</p>
</li>
<li><p><strong>什么是微任务？</strong></p>
<p>对于每个宏任务，其内部都有一个关联的微任务队列。微任务最初是为了解决异步回调的问题。对于异步回调有两种处理方案：</p>
<ol>
<li>将异步回调进行宏任务队列的入队操作。</li>
<li>将异步回调放在当前宏任务的末尾。</li>
</ol>
<p>如果采用第一种方式，那么执行回调的时机是在所有宏任务完成后，如果现在的队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</p>
<p>为了规避这一问题，v8 引入第二种执行方式，在每一个宏任务中定义一个微任务队列，在当前宏任务执行完后，会检测其中的微任务队列，如果不为空，则依次执行所有微任务，然后执行下一个宏任务。如果为空，直接执行下一个宏任务。</p>
<p>常见的微任务有<code>MutationObserver</code>、<code>Promise.then(或.reject)</code> 以及以 Promise 为基础开发的其他技术(比如<code>fetch API</code>), 还包括<code> V8 的垃圾回收过程</code>。</p>
</li>
</ol>
<h2 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h2><h3 id="事件循环-1"><a href="#事件循环-1" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="考点1：NodeJS-的事件循环"><a href="#考点1：NodeJS-的事件循环" class="headerlink" title="考点1：NodeJS 的事件循环"></a>考点1：NodeJS 的事件循环</h4><ol>
<li><p><strong>NodeJS 的事件循环和浏览器事件循环的差异？</strong></p>
<p>NodeJS 有三大关键执行阶段：</p>
<ol>
<li>执行定时器回调的阶段(<code>setTimeout</code>、<code>setInterval</code>)，检查定时器，时间到了就执行。</li>
<li>轮询(<code>poll</code>)阶段。在 NodeJS 中异步操作(文件 <code>I/O</code>、网络 <code>I/O</code>等)执行完后，通过事件通知主线程。此阶段如果定时器时间到，执行定时器回调，事件循环回到第一阶段。如果没有定时器，看回调函数队列，如果队列不为空，取出其中的方法依次执行，如果队列为空，检查是否有 <code>setImmediate</code> 的回调。有则直接进入<code>check</code> 阶段。没有则继续等待，等待回调函数加入队列后立刻执行，一段时间后自动进入 <code>check</code> 阶段。</li>
<li><code>check</code> 阶段。执行 <code>setImmediate</code> 的回调。</li>
</ol>
<p>梳理一下，NodeJS 的 eventLoop 分为下面的几个阶段:</p>
<ol>
<li>timer 阶段</li>
<li>I/O 异常回调阶段</li>
<li>空闲、预备状态(第2阶段结束，poll 未触发之前)</li>
<li>poll 阶段</li>
<li>check 阶段</li>
<li>关闭事件的回调阶段</li>
</ol>
<p>两者最主要的区别在于浏览器中的微任务是在<code>每个相应的宏任务</code>末尾执行的，而 NodeJS 中的微任务是在<code>不同阶段之间</code>执行的。</p>
</li>
</ol>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="事件循环-2"><a href="#事件循环-2" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="考点1：浏览器的事件循环"><a href="#考点1：浏览器的事件循环" class="headerlink" title="考点1：浏览器的事件循环"></a>考点1：浏览器的事件循环</h4><ol>
<li><p><strong>如何理解 EventLoop？</strong></p>
<pre class="language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolve'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// start </span>
<span class="token comment">// end</span>
<span class="token comment">// resolve</span>
<span class="token comment">// timeout</span></code></pre>

<p>执行顺序：</p>
<ol>
<li>进入全局执行上下文，整个脚本作为一个宏任务执行。同步代码立刻压入执行栈执行，打印 <code>start</code>、<code>end</code></li>
<li>setTimeOut 作为延迟任务放入到宏任务队列</li>
<li>Promise.then 作为一个微任务放入到微任务队列</li>
<li>本次宏任务执行完，检测到微任务队列不为空，执行 Promise.then</li>
<li>进入下一个宏任务，setTimeOut 执行</li>
</ol>
<p>总结如下：</p>
<ol>
<li>一开始整段脚本作为第一个宏任务执行</li>
<li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li>
<li>当前宏任务执行完出队，检测微任务队列，在微任务之间没有 UI 或网络事件的处理：它们一个立即接一个地执行，直到微任务队列为空</li>
<li>执行浏览器 UI 线程的渲染工作，浏览器发生重渲染</li>
<li>检测是否有 Web Worker 任务，有则执行</li>
<li>渲染完毕后，JS线程继续接管。执行队首新的宏任务，回到第二步，直到宏任务和微任务队列都为空</li>
</ol>
<p>同时在执行过程中有 4 种不同的情况：</p>
<ul>
<li>宏任务里面新建宏任务(主要是 <code>setTimeOut</code>)：加入宏任务的队列中</li>
<li>运行宏任务时新建微任务：加入微任务的队列中</li>
<li>运行微任务时新建宏任务：加入宏任务的队列中</li>
<li>运行微任务时新建了微任务：新创建的微任务也会马上加入微任务队列，在下次宏任务之前一定会执行。</li>
</ul>
</li>
</ol>
<h3 id="浏览器请求"><a href="#浏览器请求" class="headerlink" title="浏览器请求"></a>浏览器请求</h3><h4 id="考点1：页面加载与网络"><a href="#考点1：页面加载与网络" class="headerlink" title="考点1：页面加载与网络"></a>考点1：页面加载与网络</h4><ol>
<li><p><strong>输入 URL 到页面呈现发生了什么？</strong></p>
<ol>
<li><p><strong>网络请求：</strong></p>
<ol>
<li><p>构建请求。浏览器构建请求行：</p>
<pre class="language-none"><code class="language-none">&#x2F;&#x2F; 请求方法是GET，路径为根路径，HTTP协议版本为1.1
GET &#x2F; HTTP&#x2F;1.1</code></pre></li>
<li><p>查找强缓存，如果本地存在缓存文件，直接使用。否则进入下一步。</p>
</li>
<li><p>DNS 解析。输入的是域名，而数据包是通过 IP 地址发送的。因此需要得到真实的 IP 地址。而这一步有专门的服务系统处理。DNS 域名解析系统会将域名与其真实 IP 进行映射，得到具体 IP。</p>
<blockquote>
<p>浏览器也提供了 DNS 缓存功能。如果一个域名已经解析过，那么直接从缓存中读取。</p>
</blockquote>
</li>
<li><p>建立 TCP 连接。经过三次握手确立连接。之后进行数据传输，这个过程需要进行数据包校验，即接收方收到数据包需要向发送方返回确认信息，如果发送方没有收到，判断为数据包丢失，重新发送。数据传输完成，四次握手断开连接。</p>
<blockquote>
<p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
</blockquote>
</li>
<li><p>发送 http 请求。TCP 建立完毕，客户端可以向服务端发送 http 请求，以进行通信。一个 http 请求需要携带三样东西：请求行、请求头、请求体。</p>
</li>
</ol>
</li>
<li><p><strong>网络响应：</strong></p>
<ol>
<li>网络响应。http 请求到达服务器，服务器对其作出回应，最后把数据传输给浏览器，也就是返回网络响应。跟请求类似，网络响应包括响应行、响应头、响应体。</li>
<li>持久化。响应完成之后，如果请求头中 Connection 字段设置的是 <strong>Connection: Keep-Alive</strong>，表示建立了持久连接，TCP 连接会一直保持，之后对该站点的请求都会复用这个连接。否则断开 TCP 连接。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="浏览器存储"><a href="#浏览器存储" class="headerlink" title="浏览器存储"></a>浏览器存储</h3><h4 id="考点1：浏览器存储"><a href="#考点1：浏览器存储" class="headerlink" title="考点1：浏览器存储"></a>考点1：浏览器存储</h4><ol>
<li><p><strong>能不能说一下浏览器的本地存储？各自优劣如何？</strong></p>
<p>浏览器的本地存储方案可分为 <code>Cookie</code>、<code>WebStorage</code>、<code>IndexdDB</code>。其中 <code>WebStorage</code> 又可分为<code>localStorage</code>和<code>sessionStorage</code>。</p>
<p><code>Cookie</code> ：</p>
<p>本质上是浏览器存储的很小的文本文件。内部以键值对的形式存储。向同一个域名下发送请求，都会携带相同的  <code>Cookie</code>。因此服务器就可以解析 <code>Cookie</code>，得到客户端的状态。</p>
<p> <code>Cookie</code> 作为状态存储的工具十分轻量化，但也存在许多缺陷：</p>
<ul>
<li>容量缺陷。一般情况体积上限只有 4 KB，所以只能存储少量信息。</li>
<li>性能缺陷。 <code>Cookie</code> 紧跟域名。不管这个域名需不需要用到，请求都会携带完整的 <code>Cookie</code>，随着请求增多，存在着性能上的浪费。</li>
<li>安全缺陷。<code>Cookie</code>以纯文本的形式存储数据，很容易被截获篡改。在 <code>Cookie</code>的有效期限内发送给服务器是十分危险的。另外，在 <code>HttpOnly</code> 为 false 的情况下，可以通过 JS 脚本读取 <code>Cookie</code>信息。</li>
</ul>
<p><code>localStorage</code>：</p>
<p>和 <code>Cookie</code>类似，针对同一个域名。区别有以下几点：</p>
<ul>
<li>存储容量。<code>localStorage</code> 的上限为 5 MB，针对一个域名持久化存储。</li>
<li>只存在于客户端，不参与请求。避免了性能问题和安全问题。</li>
<li>接口封装完善。通过<code>localStorage</code>暴露在全局，并且有操作方法 <code>getItem</code> 和 <code>setItem</code>等。</li>
</ul>
<p>应用场景：由于其存储容量较大和持久化存储的特性，因此可以存储一些比较稳定的资源，像是官网 logo、Base64 格式的图片。</p>
<p><code>sessionStorage</code>：</p>
<p>与 <code>localStorage</code> 类似，区别在于其只是会话级别的存储而非持久化存储。在会话结束，也就是页面关闭后就不复存在了。</p>
<p>应用场景：存储表单消息，保证页面刷新也不会丢失之前的信息。存储本次浏览记录，关闭页面，也就不需要这些记录了。</p>
<p><code>IndexedDB</code>：</p>
<p><code>IndexedDB</code>是运行在浏览器的非关系型数据库。本质上是数据库，其存储容量理论上没有上限。</p>
<p>它支持数据库的特性，比如支持事务、二进制存储，还有一些额外特性：</p>
<ul>
<li>键值对存储。内部采用对象仓库，在这个仓库中使用键值对形式存储。</li>
<li>异步操作。数据库的读写属于 <code>I/O</code> 操作，浏览器对异步 <code>I/O</code> 提供了支持。</li>
<li>受同源策略限制，无法访问跨域数据库。</li>
</ul>
</li>
</ol>
<h4 id="考点2：浏览器缓存"><a href="#考点2：浏览器缓存" class="headerlink" title="考点2：浏览器缓存"></a>考点2：浏览器缓存</h4><ol>
<li><p><strong>能不能说一说浏览器缓存?</strong></p>
<p>浏览器缓存分两种情况：</p>
<ol>
<li><strong>强缓存。</strong></li>
<li><strong>协商缓存。</strong></li>
</ol>
<p>首先是检测有没有强缓存。这个阶段不发送 http 请求。如果命中，直接使用本地缓存。</p>
<p>在<code>HTTP/1.0</code>时期，检查的字段是 <code>Expires</code>，采用具体过期时间限制资源的使用期限。</p>
<pre class="language-none"><code class="language-none">Expires: Wed, 22 Nov 2019 08:41:00 GMT</code></pre>

<p>在<code>HTTP/1.1</code> 中，检查的字段是 <code>Cache-Control</code>。它没有采用具体的过期的时间点的方式，而是采用过期的时长控制缓存。对应的字段是 <code>max-age</code>。</p>
<pre class="language-none"><code class="language-none">Cache-Control:max-age&#x3D;3600</code></pre>

<p>并且具有非常多的属性：</p>
<ul>
<li><strong>private</strong>： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</li>
<li><strong>no-cache</strong>: 跳过当前的强缓存，发送HTTP请求，即直接进入<code>协商缓存阶段</code>。</li>
<li><strong>no-store</strong>：不进行任何形式的缓存。</li>
<li><strong>s-maxage</strong>：这和<code>max-age</code>长得比较像，但是区别在于 <code>s-maxage</code> 是针对代理服务器的缓存时间。</li>
</ul>
<p>当资源缓存的时限超过了，就会进入协商缓存阶段。</p>
<p>强缓存失效后，通过在请求头中携带 <code>tag</code> 向服务器发送请求，由服务器根据这个 <code>tag</code> 决定是否使用缓存，这就是协商缓存。</p>
<p>具体来说，这样的缓存 <code>tag</code> 分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。这两者各有优劣，并不存在谁对谁有<code>绝对的优势</code>，跟上面强缓存的两个 <code>tag</code> 不一样。</p>
<p><code>Last-Modified</code>：即最后修改时间。浏览器第一次向服务器发送请求，服务器在响应头会加上这个字段。浏览器接收后，如果再次请求，会在请求头中携带<code>If-Modified-Since</code>字段，这个字段的值也就是服务器传来的最后修改时间。</p>
<p>服务器拿到请求头的<code>If-Modified-Since</code>字段，会与服务器上该资源的最后修改时间对比，如果小于最后修改时间，说明资源更新了，需要返回新资源，和平常的 HTTP 请求响应流程一致，返回 <code>200</code>。否则返回 <code>304</code>，让浏览器直接用缓存。</p>
<p><code>ETag</code> ：是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。</p>
<p>浏览器接收到<code>ETag</code>的值，会在下次请求时，将这个值作为<code>If-None-Match</code>这个字段的内容，并放到请求头中，然后发给服务器。</p>
<p>服务器接收到<code>If-None-Match</code>后，会跟服务器上该资源的<code>ETag</code>进行比对，如果服务器上不存在，返回新资源，跟常规的 HTTP 请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。</p>
<p><strong>两种 tag 的比较：</strong></p>
<p>在精确度上，<code>ETag</code> 是更有优势的。因为 <code>Last-Modified</code>表示的是文件最后修改的时间，如果只是编辑了资源文件，而文件内容没有更改，也会造成缓存失效。<code>Last-Modified</code> 能够感知的单位时间是秒，如果文件在  1  秒内改变了多次，那么这时候的 <code>Last-Modified</code> 是不准确的。</p>
<p>在性能上，<code>Last-Modified</code>优于<code>ETag</code>，也很好理解，<code>Last-Modified</code>仅仅只是记录一个时间点，而 <code>Etag</code>需要根据文件的具体内容生成哈希值。</p>
<p>另外，如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p>
</li>
<li><p><strong>浏览器缓存的位置？</strong></p>
<p>浏览器的缓存位置一共有四种，按优先级从高到低排列分别是：</p>
<ul>
<li>Service Worker Cache</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<p>Service Worker 借鉴了 Web Worker 的思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问<code>DOM</code>。但它仍然能帮助我们完成很多有用的功能，比如<code>离线缓存</code>、<code>消息推送</code>和<code>网络代理</code>等功能。其中的<code>离线缓存</code>就是 <strong>Service Worker Cache</strong>。</p>
<p><strong>Memory Cache</strong>指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p>
<p><strong>Disk Cache</strong>就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。</p>
<p>浏览器的资源存放策略如下：</p>
<ul>
<li>比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存</li>
<li>内存使用率比较高的时候，文件优先进入磁盘</li>
</ul>
<p>Push Cache 即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，它只在会话（Session）中存在，一旦会话结束就被释放。虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用将越来越广泛。</p>
</li>
</ol>
<h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><h4 id="考点1：页面解析渲染过程"><a href="#考点1：页面解析渲染过程" class="headerlink" title="考点1：页面解析渲染过程"></a>考点1：页面解析渲染过程</h4><ol>
<li><p><strong>解释一下浏览器的解析和渲染过程</strong></p>
<p><strong>浏览器解析进程的主线程：</strong></p>
<ol>
<li><p><strong>渲染 DOM 树。</strong></p>
<p>浏览器无法直接理解 HTML 字符串，因此将这一系列的字节码转化为另一种数据结构，就是 DOM 树。本质是一个以 document 为根节点的多叉树。</p>
<p>其中涉及到解析算法，可分为两个阶段：标记化、建树。分别对应词法分析和语法分析。标记生成器会根据 HTML 标签进行记录，然后把标记的信息发送给建树器。建树器收到相应的标签，创建对应的 DOM 对象，然后加入 DOM 树中。</p>
</li>
<li><p><strong>计算 CSS 样式。</strong></p>
<p>浏览器无法直接识别 CSS 样式文本，渲染引擎在收到 CSS 文本后第一时间将其转化为结构化的 StyleSheets 对象，也就是我们常用的样式表。样式在被格式化和标准化之后，就计算每个节点的样式信息。</p>
<p>计算有两个规则：继承和层叠。每个子节点都会继承父节点的样式属性，如果父节点中没有，就默认继承浏览器默认样式(<code>UserAgent</code>)。然后是层叠规则，最终样式取决于各个属性共同作用的结果。计算完样式后，所有样式被挂载到 <code>window.getComputedStyle</code>上。</p>
</li>
<li><p><strong>生成布局树。</strong></p>
<p>现在已经生成了 DOM 结构和 DOM 节点样式，接下来就是通过浏览器的布局系统确定元素排列的方式和位置。也就是生成一颗布局树。</p>
<p>大致如下：</p>
<ol>
<li>遍历生成的 DOM 树节点，把他们添加到布局树中。(仅包含可见元素)</li>
<li>计算布局节点的坐标位置。</li>
</ol>
</li>
</ol>
<p><strong>浏览器渲染进程的主线程：</strong></p>
<ol>
<li><p><strong>建造图层树。</strong></p>
<p>浏览器在绘制页面之前，还需要处理一些特殊的情况。比如 3D变换、如何控制层叠上下文元素显示和隐藏。</p>
<p>一般情况下，节点的图层默认属于其父节点的图层(也叫合成图层)。在某些情况需要提升为一个单独的合成层。这个过程主要涉及显示合成和隐式合成。</p>
<p>显示合成：</p>
<ol>
<li>拥有层叠上下文的节点。包括：<ul>
<li>HTML 根元素本身就具有层叠上下文。</li>
<li>position 不为 <code>static</code>并且设置了 <code>z-index</code>属性，产生层叠上下文。</li>
<li>元素的 opacity(透明度) 不为 1</li>
<li>元素的 transform(变换) 不为 none</li>
<li>元素的 filter(滤镜) 不为 none</li>
<li>元素的 isolation(创建新的层叠上下文) 为 isolation</li>
<li>will-change 指定的属性值为上面任意一个。</li>
</ul>
</li>
<li>需要剪裁的部分。图层溢出，产生滚动条，也会提升为单独的图层。</li>
</ol>
<p>隐式合成：</p>
<p>如果一个在层叠上下文中等级较低的节点形成了单独的图层，那么等级在它之上的所有节点都会形成一个单独的图层。这会大大加大内存的压力，甚至让页面崩溃，这就是层爆炸的原因。</p>
</li>
<li><p><strong>生成绘制列表。</strong></p>
<p>接下来浏览器的绘制引擎会将图层的绘制拆分为一条条指令。然后将这些指令组合成待绘制列表，规划之后的绘制操作。</p>
</li>
<li><p><strong>合成线程拆分图块。</strong></p>
<p>浏览器中的绘制是由单独的线程来实施的，这个线程是合成线程。绘制列表准备好后，渲染进程的主线程会将绘制列表提交给合成线程。</p>
<p>当页面非常长的时候，绘制过程是十分消耗时间的，因此需要合成线程将其拆分成为一个个图块。这样可以大大加速页面的首屏展示。因为之后图块数据要进入 GPU 内存，从浏览器上传到 GPU 内存的速度很慢，Chrome 采用降低首次加载图片分辨率的策略。在合成线程绘制完毕后，再将当前低分辨率的图块替换。</p>
</li>
<li><p><strong>调用线程池生成位图。</strong></p>
<p>合成线程专门维护了一个栅格化线程池，利用它将图块转化成位图。合成线程会将视口最近的图块交给栅格化线程池。这个过程会使用到 GPU 加速。最后处理得到的位图返回给合成线程。</p>
</li>
<li><p><strong>发送给浏览器进程。</strong></p>
<p>合成线程在栅格化操作完成后，会生成绘制命令，并发送给浏览器进程，浏览器根据这个命令，把页面内容绘制到内存，同时发送给显卡。</p>
</li>
<li><p><strong>显卡缓存图像，显示器显示。</strong></p>
<p>无论是手机屏幕还是 PC 显示器，都有一个固定的刷新频率。一般是 60 HZ，即60帧。也就是一秒更新 60 次图片。而每次更新的图片都来自于显卡的前缓冲区 。显卡接收到浏览器传来的页面后，先合成对应的图像，并保存到后缓冲区。之后系统自动将前后缓冲区对调，如此循环更新。</p>
</li>
</ol>
</li>
</ol>
<h4 id="考点2：回流重绘"><a href="#考点2：回流重绘" class="headerlink" title="考点2：回流重绘"></a>考点2：回流重绘</h4><ol>
<li><p><strong>什么是重绘和回流？</strong></p>
<p><strong>回流：</strong></p>
<p>回流也叫重排。简单来说，当我们对 DOM 结构进行修改，导致其几何尺寸变化的时候，会发生<code>回流</code>的过程。</p>
<p>以下的操作会触发回流：</p>
<ol>
<li>一个 DOM 元素的几何属性发生变化，常见的有 <code>width、height、padding、margin、left、top、border</code>等。</li>
<li>DOM 节点发生增减或移动。</li>
<li>读写 <code>offset</code>、<code>scroll</code>和 <code>client</code> 属性时，为了获取这些计算值浏览器需要进行回流。</li>
<li>调用 <code>window.getComputedStyle</code> 方法。</li>
</ol>
<p><strong>重绘：</strong></p>
<p>重绘是在不影响几何属性的情况下，DOM 的修改导致了样式的变化。</p>
<p>重绘过程不涉及 DOM 结构的变化，元素的位置没有更新，因此不需要重新建立布局树和图层树。</p>
<p>重绘不一定导致回流，但回流一定发生重绘。</p>
<p><strong>实践意义：</strong></p>
<ol>
<li>应该尽量少使用 style，多使用修改 class 的方式。</li>
<li>使用<code>createDocumentFragment</code>进行批量的 DOM 操作。</li>
<li>对于 resize、scroll 进行防抖节流处理。</li>
<li>添加 will-change: tranform，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。</li>
</ol>
</li>
</ol>
<h4 id="考点3：渲染与刷新"><a href="#考点3：渲染与刷新" class="headerlink" title="考点3：渲染与刷新"></a>考点3：渲染与刷新</h4><ol>
<li><p><strong>setTimeout 与 requestAnimationFrame 的区别？</strong></p>
<p><code>requestAnimationFrame </code>是 H5 新增的 API。类似于 <code>setTimeOut</code> 定时器。它只能在浏览器中使用，是专门为动画属性提供，让 <code>DOM 动画</code>，<code>canvas 动画</code>，<code>SVG 动画</code>和 <code>webGL 动画</code>有一个统一的刷新机制。基本思想是让重绘频率与这个动画的刷新频率相近。所以它不需要像 <code>setTimeOut</code> 一样传递一个时间，而是由系统获取并使用显示器的刷新率，而且是发生在 UI 渲染之前。</p>
<p><code>setTimeOut</code> 是人为地设定一个间隔时间不断改变图像，会受到显示器分辨率的影响。不同的显示器刷新率不同，如果与 <code>setTimeOut</code> 指定的刷新间隔不一致，可能会造成页面卡顿，掉帧。</p>
<p>因此，使用 <code>requestAnimationFrame</code> 最大的优势是确保在一次刷新中只执行一次，节约资源，节省电源。</p>
</li>
</ol>
<h3 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><h4 id="考点1：同源策略"><a href="#考点1：同源策略" class="headerlink" title="考点1：同源策略"></a>考点1：同源策略</h4><ol>
<li><p><strong>什么是浏览器同源策略？</strong></p>
<p><em>源</em>是指 URL 中由协议、域名、端口共同组成的部分。同源策略是一种约定，它是浏览器最核心也最基本的安全功能。可分为两种：</p>
<p>DOM 同源策略：禁止对不同源页面 DOM 进行操作。主要场景是 iframe 跨域。禁止不同域名的 iframe 互相访问。</p>
<p>XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发送 Http 请求。</p>
</li>
<li><p>同源策略有什么限制？</p>
<ul>
<li><code>Cookie</code> 、<code>LocalStorage</code> 和 <code>IndexDB</code>无法读取。</li>
<li>无法获取或操作另一个资源页面的 <code>DOM</code>。</li>
<li><code>AJAX</code>请求拦截。</li>
</ul>
</li>
</ol>
<h4 id="考点2：跨域"><a href="#考点2：跨域" class="headerlink" title="考点2：跨域"></a>考点2：跨域</h4><ol>
<li><p><strong>为什么要有跨域限制？</strong></p>
<p>如果没有DOM 同源策略，不同域的 iframe 之间可以相互访问，那么黑客可以通过在 iframe 中嵌套真实网站，在用户输入信息后从主网站获取到其中的 DOM 节点。</p>
<p>如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF(<strong>跨站请求伪造</strong>) 攻击，在用户登录正常网站后，在浏览器中存储了 cookie。如果用户浏览了另一个恶意网站，执行了其中的恶意 AJAX 脚本，请求会默认把用户的 cookie 也携带上，造成用户数据泄露。</p>
</li>
<li><p><strong>请求跨域的解决方案？</strong></p>
<p><code>CORS(跨域资源共享)</code>：</p>
<p>是一个 W3C 标准，规定了在必须访问跨域资源时，浏览器和服务器之间如何沟通。其背后的基本思想，是通过自定义的请求头字段来决定请求和响应是成功还是失败。CORS 需要浏览器和服务器同时支持，并且依赖于后端的配置。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>简单请求：需要在请求头中额外附带一个 <code>Origin</code> 字段，包含请求来源信息。服务器认为可以接收，就在 <code>Access-Control-Allow-Origin</code> 中返回相同的信息。没有这个头部信息或者不匹配，浏览器就驳回请求。如果需要携带 cookie，需要额外设置 <code>withCredentials: true</code>，服务器需要设置响应头部 <code>Access-Control-Allow-Credentials: true</code>。</p>
<p>非简单请求：浏览器在发送真实请求之前，先发送一个 Preflight 请求给服务器。使用 OPTIONS 方法，发送下列头部：</p>
<ul>
<li><p>Origin：与简单的请求相同。</p>
</li>
<li><p>Access-Control-Request-Method: 请求自身使用的方法。</p>
</li>
<li><p>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</p>
</li>
</ul>
<p>服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p>
<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同。</li>
<li>Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。</li>
<li>Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。</li>
<li>Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。</li>
</ul>
<p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。</p>
<p>优点：</p>
<ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求。</li>
</ul>
<p>缺点：</p>
<ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
<p><code>JSONP</code>:</p>
<p>原理是利用 <code>&lt;script&gt;</code> 标签在浏览器上不受同源限制。</p>
<p>Web前端事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的script标签发起一个请求(将回调函数的名称放到这个请求的query参数里)，然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，前端的script标签请求到这个执行的回调函数后会立刻执行，于是就拿到了执行的响应数据。</p>
<p>优点：简单，兼容性好，可以解决主流浏览器的跨域访问限制。</p>
<p>缺点：安全性低，可能会遭受 XSS 攻击。有局限性，只支持 GET 方法。</p>
<p><code>WebSocket</code>：</p>
<p>客户端与服务端双向通信的一种协议。<strong>在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。</strong>同时，<code>WebSocket</code> 在建立连接时需要借助 <code>HTTP</code> 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。</p>
<p>优点：数据轻量，性能开销小，通信高效。支持文本和二进制数据。</p>
<p>缺点：是长连接，受网络限制大。浏览器支持程度不一。服务器维护长连接需要一定成本。</p>
<p><code>document.domain</code>：</p>
<p>通过将不同子域的 <code>document.domain</code>设为相同主域实现同域。</p>
<p>优点：实现简单。适合 iframe 跨域。</p>
<p>缺点：此方案仅限主域相同，子域不同的跨域应用场景。</p>
<p><code>window.name</code>：</p>
<p>原理是利用 window 的 location 变化，重新加载后，它的 name 属性可以依然保持不变。每个页面对<code>window.name</code> 都有读写的权限，不存在跨域问题。</p>
</li>
<li><p><strong>代理解决跨域的常用方案？</strong></p>
<p><code>nginx反向代理</code>：</p>
<p><strong>同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。</strong></p>
<p>实现思路：通过 nginx 配置一个代理服务器(域名与domain1相同)做跳板机，反向代理访问domain2接口(需要配置转发的服务器地址)，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<p><code>Nodejs中间件代理</code>：</p>
<p>node中间件实现跨域代理，通过启动 Nodejs 代理服务器，实现数据转发。也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<p><code>webpack proxy</code>：</p>
<p>借助 <code>webpack-dev-server</code> 实现请求转发。仅适用于开发者模式。</p>
</li>
</ol>
<h4 id="考点3：浏览器攻击"><a href="#考点3：浏览器攻击" class="headerlink" title="考点3：浏览器攻击"></a>考点3：浏览器攻击</h4><ol>
<li><p><strong>能不能说一下 XSS 攻击？</strong></p>
<p>XSS 全称是 <code>Cross-Site-Scripting</code>，即跨站脚本。是指在浏览器中执行恶意脚本(无论同域还是跨域)。</p>
<p>一般可以做到：</p>
<ul>
<li>窃取 Cookie</li>
<li>监听用户行为</li>
<li>修改 DOM 伪造登录表单</li>
<li>生成浮窗广告</li>
</ul>
<p>XSS 攻击的实现有三种方式——<strong>存储型</strong>、<strong>反射型</strong>和<strong>文档型</strong>。</p>
<p><code>存储型</code>，顾名思义就是将恶意脚本存储了起来，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。</p>
<p>常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中<code>直接执行</code>, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。</p>
<p><code>反射型</code>，指的是恶意脚本作为<strong>网络请求</strong>的一部分。恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和<code>存储型</code>不一样的是，服务器并不会存储这些恶意脚本。</p>
<p><code>文档型</code>的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后<strong>修改里面的 html 文档</strong></p>
<p>这样的劫持方式包括<code>WIFI路由器劫持</code>或者<code>本地恶意软件</code>等。</p>
</li>
<li><p><strong>能不能说一说CSRF攻击?</strong></p>
<p><code>CSRF(Cross-site request forgery)</code>， 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户<strong>目前的登录状态</strong>发起跨站请求。</p>
<p>为了防范 <code>CSRF</code>攻击，主要使用的技术是 <code>JWT(Json Web Token)</code>。</p>
<p>一个完整的 <code>JWT</code> 包含三个部分：</p>
<p><code>Header</code>：是一个 <code>Json</code> 对象，描述 <code>JWT</code> 的元数据。</p>
<p><code>Payload</code>：是一个 <code>Json</code> 对象，描述了本次会话的信息。<code>JWT</code> 官方规定了下面几个官方的字段供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p><code>Signature</code>：对前两部分进行签名加密，防止数据篡改。首先需要定义一个秘钥，这个秘钥只有服务器才知道，不能泄露给用户，然后使用<code>Header</code>中指定的签名算法(默认情况是<code>HMAC SHA256</code>)，算出签名以后将<code>Header、Payload、Signature</code>三部分拼成一个字符串，每个部分用 <code>.</code> 分割开来，就可以返给用户了。</p>
<p>之后，浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。通常第三方站点无法拿到这个 <code>token</code>， 因此也就是被服务器给拒绝。</p>
</li>
</ol>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sticla</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://blog.sticla.top/2021/08/15/front-end-interview-browser/" title="备战前端面试--浏览器和V8引擎篇">https://blog.sticla.top/2021/08/15/front-end-interview-browser/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/08/15/front-end-interview-review-es/" rel="prev" title="备战前端面试--esnext篇"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">备战前端面试--esnext篇</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/08/14/class-and-this/" rel="next" title="Class 子类没有 this？ Class 真的只是语法糖吗？"><span class="post-nav-text">Class 子类没有 this？ Class 真的只是语法糖吗？</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/li-sticla/li-sticla.github.io/issues?q=is:issue+备战前端面试--浏览器和V8引擎篇">GitHub Issues</a></div><div id="valine-container"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js", () => {
  const valineConfig = {"enable":true,"appId":"fhhkJbCVeplMMyPTL5CmiGOV-MdYXbMMI","appKey":"gXz6Ktd45hdMO77EYNY9cRds","placeholder":"有任何问题请留言，看到会回复滴","avatar":null,"pageSize":10,"visitor":true,"highlight":true,"recordIP":false,"enableQQ":true,"avatar_cdn":"https://gravatar.loli.net/avatar/","meta":["nick","mail","link"],"el":"#valine-container","lang":"en"}
  valineConfig.path = "/2021/08/15/front-end-interview-browser/"
  new Valine(valineConfig)
}, window.Valine);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sticla</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.2</span></div><div class="live_time"><span>本博客已萌萌哒地存活了</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-03-19T21:17:49');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>