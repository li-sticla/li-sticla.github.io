<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="sticla"><meta name="copyright" content="sticla"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>备战前端面试--工具与优化篇 | sticla studio</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#6200ee"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"blog.sticla.top","root":"/","title":"sticla studio","version":"1.5.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-CCS65Z3P4C"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-CCS65Z3P4C');
}</script><meta name="description" content="备战前端面试—工具与优化篇Webpack 简述一下 webpack 的原理？ webpack 是一个用于现代JavaScript应用程序的静态模块打包工具。 当 webpack 处理应用程序时，会先从入口文件(通过entry指定)开始，递归查询依赖(这个过程使用 babel 来遍历 AST 抽象语法树，提取其中的 import 声明)。 随后生成依赖图谱(使用了图这种数据结构，把各个模块的依赖推入">
<meta property="og:type" content="article">
<meta property="og:title" content="备战前端面试--工具与优化篇">
<meta property="og:url" content="https://blog.sticla.top/2021/08/20/front-end-interview-review-tools/index.html">
<meta property="og:site_name" content="sticla studio">
<meta property="og:description" content="备战前端面试—工具与优化篇Webpack 简述一下 webpack 的原理？ webpack 是一个用于现代JavaScript应用程序的静态模块打包工具。 当 webpack 处理应用程序时，会先从入口文件(通过entry指定)开始，递归查询依赖(这个过程使用 babel 来遍历 AST 抽象语法树，提取其中的 import 声明)。 随后生成依赖图谱(使用了图这种数据结构，把各个模块的依赖推入">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-08-20T18:06:21.000Z">
<meta property="article:modified_time" content="2023-02-02T06:23:29.270Z">
<meta property="article:author" content="sticla">
<meta property="article:tag" content="interview">
<meta property="article:tag" content="Webpack">
<meta property="article:tag" content="Redux">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="sticla"><img width="96" loading="lazy" src="https://cdn.jsdelivr.net/gh/li-sticla/picBed@latest/EAXX2-BUwAA2FuM (2).jpg" alt="sticla"><span class="site-author-status" title="我爱摸鱼">😭</span></a><div class="site-author-name"><a href="/about/">sticla</a></div><span class="site-name">sticla studio</span><sub class="site-subtitle">Change the world！</sub><div class="site-desciption">只有弱者才睡觉！</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">20</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/li-sticla" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:yuanzichao@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1619244804" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/5050630" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/sticla_yuuri" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/sticla" title="Telegram" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E6%88%98%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E5%B7%A5%E5%85%B7%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">备战前端面试—工具与优化篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Webpack"><span class="toc-number">1.1.</span> <span class="toc-text">Webpack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redux"><span class="toc-number">1.2.</span> <span class="toc-text">Redux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">项目性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">1.4.</span> <span class="toc-text">后记</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://blog.sticla.top/2021/08/20/front-end-interview-review-tools/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sticla"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="sticla studio"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">备战前端面试--工具与优化篇</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-08-20 18:06:21" itemprop="dateCreated datePublished" datetime="2021-08-20T18:06:21+00:00">2021-08-20</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2023-02-02 06:23:29" itemprop="dateModified" datetime="2023-02-02T06:23:29+00:00">2023-02-02</time></div><span class="leancloud_visitors" id="/2021/08/20/front-end-interview-review-tools/" data-flag-title="备战前端面试--工具与优化篇"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%AD%A6%E4%B9%A0-tools/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习-tools</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/interview/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">interview</span></a><a class="tag" href="/tags/Webpack/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Webpack</span></a><a class="tag" href="/tags/Redux/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Redux</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/429930d44169a040b9b3a3e187e2f63e?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">sticla</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#6200ee;"><h1 id="备战前端面试—工具与优化篇"><a href="#备战前端面试—工具与优化篇" class="headerlink" title="备战前端面试—工具与优化篇"></a>备战前端面试—工具与优化篇</h1><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><ol>
<li><p><strong>简述一下 webpack 的原理？</strong></p>
<p><code>webpack</code> 是一个用于现代<code>JavaScript</code>应用程序的静态模块打包工具。</p>
<p>当 <code>webpack</code> 处理应用程序时，会先从入口文件(通过entry指定)开始，递归查询依赖(这个过程使用 babel 来遍历 AST 抽象语法树，提取其中的 import 声明)。</p>
<p>随后生成依赖图谱(使用了图这种数据结构，把各个模块的依赖推入数组)。</p>
<p>webpack 将各个模块的代码封装到函数(seal)中，使用内部的一些工具函数处理依赖关系、上下文。</p>
<p>实现一个加载方法将封装各个模块的函数引入(chunk)，置于同一个执行环境。</p>
<p>执行加载方法，准备输出产物。</p>
<p>确认好输出内容后，根据配置输出的路径和文件名，把文件内容写入到文件系统。</p>
</li>
<li><p><strong>说说 webpack 的常用配置？</strong></p>
<pre class="language-js" data-language="js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// __dirname值为所在文件的目录，context默认为执行webpack命令所在的目录</span>
    context<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// 必填项，编译入口，webpack启动会从配置文件开始解析,如下三种(还有一种动态加载entry的方式就是给entry传入一个函数，这个在项目比较大，页面很多的情况下可以优化编译时间)</span>
    entry<span class="token operator">:</span> <span class="token string">'./app/entry'</span><span class="token punctuation">,</span> <span class="token comment">// 只有一个入口，入口只有一个文件</span>
    entry<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'./app/entry1'</span><span class="token punctuation">,</span> <span class="token string">'./app/entry2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 只有一个入口，入口有两个文件</span>
       <span class="token comment">// 两个入口</span>
    entry<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        entry1<span class="token operator">:</span> <span class="token string">'./app/entry1'</span><span class="token punctuation">,</span>
        entry2<span class="token operator">:</span> <span class="token string">'./app/entry2'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 输出文件配置</span>
    output<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 输出文件存放的目录，必须是string类型的绝对路径</span>
        path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token comment">// 输出文件的名称</span>
        filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
        filename<span class="token operator">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span> <span class="token comment">// 配置了多个入口entry是[name]的值会被入口的key值替换，此处输出文件会输出的文件名为entry1.js和entry2.js</span>
        filename<span class="token operator">:</span> <span class="token punctuation">[</span>chunkhash<span class="token punctuation">]</span><span class="token punctuation">.</span>js<span class="token punctuation">,</span> <span class="token comment">// 根据chunk的内容的Hash值生成文件的名称，其他只还有id，hash，hash和chunkhash后面可以使用:number来取值，默认为20位，比如[name]@[chunkhash:12].js,</span>
        <span class="token comment">// 文件发布到线上的资源的URL前缀，一般用于描述js和css位置，举个例子，打包项目时会导出一些html,那么html里边注入的script和link的地址就是通过这里配置的</span>
        publicPath<span class="token operator">:</span> <span class="token string">"https://cdn.example.com/assets/"</span><span class="token punctuation">,</span> <span class="token comment">// CDN（总是 HTTPS 协议）</span>
        publicPath<span class="token operator">:</span> <span class="token string">"//cdn.example.com/assets/"</span><span class="token punctuation">,</span> <span class="token comment">// CDN (协议相同)</span>
        publicPath<span class="token operator">:</span> <span class="token string">"/assets/"</span><span class="token punctuation">,</span> <span class="token comment">// 相对于服务(server-relative)</span>
        publicPath<span class="token operator">:</span> <span class="token string">"assets/"</span><span class="token punctuation">,</span> <span class="token comment">// 相对于 HTML 页面</span>
        publicPath<span class="token operator">:</span> <span class="token string">"../assets/"</span><span class="token punctuation">,</span> <span class="token comment">// 相对于 HTML 页面</span>
        publicPath<span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">// 相对于 HTML 页面（目录相同）</span>
        <span class="token comment">// 当需要构建的项目可以被其他模块导入使用，会用到libraryTarget和library</span>
        library<span class="token operator">:</span> <span class="token string">'xxx'</span><span class="token punctuation">,</span> <span class="token comment">// 配置导出库的名称，但是和libraryTarget有关，如果是commonjs2默认导出这个名字就没啥用</span>
        <span class="token comment">// 从webpack3.1.0开始，可以为每个target起不同的名称</span>
        library<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            root<span class="token operator">:</span> <span class="token string">"MyLibrary"</span><span class="token punctuation">,</span>
            amd<span class="token operator">:</span> <span class="token string">"my-library"</span><span class="token punctuation">,</span>
            commonjs<span class="token operator">:</span> <span class="token string">"my-common-library"</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        libraryTarget<span class="token operator">:</span> <span class="token string">'umd'</span><span class="token punctuation">,</span> <span class="token comment">// 导出库的类型，枚举值: umd、commonjs2、commonjs，amd、this、var(默认)、assign、window、global、jsonp</span>
        <span class="token comment">// 需要单独导出的子模块，这样可以直接在引用的时候使用子模块，默认的时候是_entry_return_</span>
        libraryExport<span class="token operator">:</span> <span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token comment">// __entry_return_.default</span>
        libraryExport<span class="token operator">:</span> <span class="token string">'MyModule'</span><span class="token punctuation">,</span> <span class="token comment">// __entry_return_.MyModule</span>
        libraryExport<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'MyModule'</span><span class="token punctuation">,</span> <span class="token string">'MySubModule '</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 使用数组代表到指定模块的取值路径 __entry_return_.MyModule.MySubModule</span>
        <span class="token comment">// 配置无入口的chunk在输出时的文件名称，但仅用于在运行过程中生成的Chunk在输出时的文件名称，这个应该一般和插件的导出有关，支持和filename一样的内置变量</span>
        chunkFilename<span class="token operator">:</span> <span class="token string">'[id].js'</span><span class="token punctuation">,</span>
        <span class="token comment">// 是否包含文件依赖相关的注释信息，在mode为development默认为true</span>
        pathinfo<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token comment">// JSONP异步加载chunk，或者拼接多个初始chunk(CommonsChunkPlugin,AggressiveSplittingPlugin)</span>
        jsonpFunction<span class="token operator">:</span> <span class="token string">'myWebpackJsonp'</span><span class="token punctuation">,</span>
        <span class="token comment">// 此选项会向硬盘写入一个输出文件，只在devtool启动了sourceMap选项时采用，默认为`[file].map`,除了和filename一样外还可以使用[file]</span>
        sourceMapFilename<span class="token operator">:</span> <span class="token string">'[file].map'</span><span class="token punctuation">,</span>
        <span class="token comment">// 浏览器开发者工具里显示的源码模块名称，此选项仅在 「devtool 使用了需要模块名称的选项」时使用，使用source-map调试，关联模块鼠标移动到上面的时候显示的地址，默认这个值是有的，一般不需要关心</span>
        devtoolModuleFilenameTemplate<span class="token operator">:</span> <span class="token string">'test://[resource-path]'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 配置模块相关</span>
    module<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        rules<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// 配置loaders</span>
            <span class="token punctuation">&#123;</span>
                test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.jsx?$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token comment">// 匹配规则，匹配文件使用，一般使用正则表达值</span>
                include<span class="token operator">:</span> <span class="token punctuation">[</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 只会命中这个目录文件</span>
                exclude<span class="token operator">:</span> <span class="token punctuation">[</span>path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__diranme<span class="token punctuation">,</span> <span class="token string">'app/demo-files'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 命中的时候排除的目录</span>
                use<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// 使用的loader，每一项为一个loader，从该数组的最后一个往前执行</span>
                    <span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token comment">// loader的名称,这样则是使用默认配置，可以在后面加!配置属性，也可以用下面方式</span>
                    <span class="token punctuation">&#123;</span>
                        loader<span class="token operator">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span> <span class="token comment">// loader的名称</span>
                        options<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// loader接受的参数</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">]</span><span class="token punctuation">,</span>
                noParse<span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token comment">// 不用解析和处理的模块 RegExp | [RegExp] | function（从 webpack 3.0.0 开始）</span>
                    <span class="token operator">/</span>jquery<span class="token operator">|</span>lodash<span class="token operator">/</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">]</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 配置插件</span>
    plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token comment">// 压缩js的plugin</span>
      <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>UglifyJsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        compress<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
          warnings<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
          drop_console<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 解析文件引用的模块的配置</span>
    resolve<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 模块的根目录,默认从node_modules开始找</span>
        modules<span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token string">'node_modules'</span><span class="token punctuation">,</span>
            <span class="token string">'browser_modules'</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment">// 模块的后缀名，我们引入模块有时候不写扩展名，自动补充扩展名的顺序如下</span>
        extensions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'.js'</span><span class="token punctuation">,</span> <span class="token string">'.json'</span><span class="token punctuation">,</span> <span class="token string">'.jsx'</span><span class="token punctuation">,</span> <span class="token string">'.css'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment">// 模块解析时候的别名</span>
        alias<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 那么导入模块时则可以写import myComponent from '$component/myComponent';</span>
            $component<span class="token operator">:</span> <span class="token string">'./src/component'</span><span class="token punctuation">,</span>
            <span class="token comment">// 末尾加$精确匹配</span>
            xyz$<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'path/to/file.js'</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token comment">// 此选项决定优先使用package.json配置哪份导出文件</span>
        mainFields<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'jsnext:main'</span><span class="token punctuation">,</span> <span class="token string">'browser'</span><span class="token punctuation">,</span> <span class="token string">'main'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token comment">// 是否强制导入语句写明后缀</span>
        enforceExtension<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token comment">// 是否将符号链接(symlink)解析到它们的符号链接位置(symlink location)</span>
        symlinks<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 选择一种 source map 格式来增强调试过程。不同的值会明显影响到构建(build)和重新构建(rebuild)的速度。</span>
    devtool<span class="token operator">:</span> <span class="token string">'source-map'</span><span class="token punctuation">,</span>
    <span class="token comment">// 配置输出代码的运行环境，可以为async-node，electron-main，electron-renderer，node，node-webkit，web(默认)，webworker</span>
    target<span class="token operator">:</span> <span class="token string">'web'</span><span class="token punctuation">,</span>
    externals<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 使用来自于js运行环境提供的全局变量</span>
        jquery<span class="token operator">:</span> <span class="token string">'jQuery'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 控制台输出日志控制</span>
    stats<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        assets<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 添加资源信息</span>
        colors<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 控制台日志信息是否有颜色</span>
        errors<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 添加错误信息</span>
        errorDetails<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 添加错误的详细信息（就像解析日志一样）</span>
        hash<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 添加 compilation 的哈希值</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    devServer<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 本地开发服务相关配置</span>
        proxy<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 代理到后端服务接口</span>
            <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000'</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        contentBase<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 配置devserver http服务器文件的根目录</span>
        compress<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否开启gzip压缩</span>
        hot<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否开启模块热交换功能</span>
        https<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 是否开启https模式</span>
        historyApiFallback<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否开发HTML5 History API网页</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    profile<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否捕捉webpack构建的性能信息，用于分析是什么原因导致的构建性能不佳</span>
    cache<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 缓存生成的 webpack 模块和 chunk，来改善构建速度。缓存默认在观察模式(watch mode)启用。</span>
    cache<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果传递一个对象，webpack 将使用这个对象进行缓存。保持对此对象的引用，将可以在 compiler 调用之间共享同一缓存：</span>
        cache<span class="token operator">:</span> SharedCache  <span class="token comment">// let SharedCache = &#123;&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    watch<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 是否启用监听模式</span>
    watchOptions<span class="token operator">:</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 监听模式选项</span>
        ignored<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">node_modules</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token comment">// 不监听的文件或文件夹，支持正则匹配，默认为空</span>
        aggregateTimeout<span class="token operator">:</span> <span class="token number">300</span><span class="token punctuation">,</span> <span class="token comment">//监听到变化后，300ms再执行动作，节流，防止文件更新频率太快导致重新编译频率太快</span>
        poll<span class="token operator">:</span> <span class="token number">1000</span> <span class="token comment">// 检测文件是否变化，间隔时间</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token comment">// 输出文件的性能检查配置</span>
    perfomance<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
        hints<span class="token operator">:</span> <span class="token string">'warning'</span><span class="token punctuation">,</span> <span class="token comment">// 有性能问题时输出警告</span>
        hints<span class="token operator">:</span> <span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token comment">// 有性能问题时输出错误</span>
        hints<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 关闭性能检查</span>
        maxAssetSize<span class="token operator">:</span> <span class="token number">200000</span><span class="token punctuation">,</span> <span class="token comment">// 最大文件大小，单位bytes</span>
        maxEntrypointSize<span class="token operator">:</span> <span class="token number">400000</span><span class="token punctuation">,</span> <span class="token comment">// 最大入口文件的大小，单位bytes</span>
        <span class="token comment">// 此属性允许 webpack 控制用于计算性能提示的文件。</span>
        <span class="token function-variable function">assetFilter</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">assetFilename</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> assetFilename<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'.css'</span><span class="token punctuation">)</span> <span class="token operator">||</span> assetFilename<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
<li><p><strong>你常用的 loader 有哪些？</strong></p>
<ul>
<li>file-loader：加载文件资源，如字体、图片，具有移动、复制、删除功能。</li>
<li>url-loader：计算文件的 base64 编码，常用于加载较小图片，转化为 DataURL 来减少请求次数。</li>
<li>babel-loader：加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题。</li>
<li>ts-loader：加载 ts / tsx 文件，编译 TypeScript。</li>
<li>style-loader：将 css 文件以 <code>&lt;style&gt;</code> 的形式插入 html 中。</li>
<li>css-loader：分析 <code>@import </code>和 <code>url()</code> 引入 css 文件和对应资源。</li>
<li>less-loader / sass-loader：css 预处理器，在 css 中新增了许多语法，提高了开发效率。</li>
<li>html-minify-loader：压缩HTML。</li>
</ul>
</li>
<li><p><strong>介绍一下 webpack 常用的 plugin？</strong></p>
<p>通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。其本质是一个具有<code>apply</code>方法的<code>javascript</code>对象。</p>
<p><strong>用于修改行为：</strong></p>
<ul>
<li>DefinePlugin：编译时配置全局变量。</li>
<li>ignore-plugin：忽略部分文件。</li>
</ul>
<p><strong>用于优化：</strong></p>
<ul>
<li>extract-text-webpack-plugin：提取 CSS 到一个单独的文件中。</li>
<li>optimize-css-assets-webpack-plugin：对 css 快速去重。</li>
<li>webpack-bundle-analyzer：一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。</li>
<li>happypack：通过多进程模型加快代码构建。</li>
<li>DllPlugin：分离打包加快构建。</li>
<li>prepack-webpack-plugin：通过 Facebook 的 Prepack 优化输出的 JavaScript 代码性能。</li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码。</li>
<li>imagemin-webpack-plugin：压缩图片文件。</li>
<li>HotModuleReplacementPlugin：模块热替换。</li>
</ul>
<p><strong>用于提高开发效率：</strong></p>
<ul>
<li>ProvidePlugin：从环境中提供的全局变量中加载模块，而不用导入对应的文件，代替require 和 import。</li>
<li>html-webpack-plugin：可以根据模板自动生成 html 代码，并自动引用 css 和 js 文件。</li>
<li>web-webpack-plugin：方便的为单页应用输出 HTML，比 html-webpack-plugin 好用。</li>
<li>clean-webpack-plugin：自动清理构建目录。</li>
</ul>
</li>
<li><p><strong>说说 Loader 和 Plugin 的区别？</strong></p>
<p>从功能上来看：</p>
<p>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中。</p>
<p>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他功能。</p>
<hr>
<p>从整个运行时机上来看：</p>
<p>loader 运行在打包之前。</p>
<p>plugins 在整个编译周期都起作用。</p>
<hr>
<p>从原理上看：</p>
<p>loader 实质是一个转换器函数。因为 webpack 运行在 nodeJS 环境，只能识别 js 文件，loader 以 webpack 对象作为自己的上下文，接收一个文件源内容作为参数，对其进行编译转化。</p>
<p>plugins 本质是发布订阅模式中的订阅者。它监听了 webpack 生命周期的一些事件，在事件广播时触发回调函数，执行其中的逻辑，通过 webpack  的 API 来改变 webpack 行为。在配置 plugins 时需要 new 一个实例对象。</p>
</li>
<li><p><strong>说说 webpack 的热更新是如何做到的？原理是什么？</strong></p>
<p><code>HMR</code> 全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。</p>
<p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失。如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。</p>
<p>在<code>webpack</code>中配置开启：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 开启 HMR 特性</span>
    hot<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token comment">// hotOnly: true</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>需要有一些额外的操作，指定哪些模块发生更新时进行 <code>HMR</code>：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>hot<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    module<span class="token punctuation">.</span>hot<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">'./util.js'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"util.js更新了"</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<hr>
<p>原理：</p>
<p>通过 webpack-dev-server 建立两个服务器：静态资源代理服务器(express)和 socket 服务器。</p>
<p>express server 将打包后的资源发送给浏览器，通过 AJAX 被浏览器请求和解析。</p>
<p>socket server 建立 websocket 长连接，实现双向瞬时通信。</p>
<p>socket server 监听到对应的模块变动，生成两个文件 <code>.json</code>(manifest 文件，包含了 <code>hash</code> 和 <code>chundId</code>，用来说明变化的内容) 和 <code>.js</code>(update chunk)。</p>
<p>通过长连接，socket server 可以直接将这两个文件主动推送给浏览器。</p>
<p>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新。</p>
</li>
<li><p><strong>说说 webpack proxy 工作原理？为什么能解决跨域?</strong></p>
<p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器。</p>
<p>其目的是为了便于开发者在开发模式下解决跨域问题(浏览器安全策略限制)。</p>
<p>想要实现代理首先需要一个中间服务器，<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code>，<strong>只适用在开发阶段</strong>。</p>
<p><code>proxy</code>的工作原理实质上是利用<code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器，利用服务器之间通信不存在跨域来解决问题。目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。</p>
</li>
<li><p><strong>tree-shaking 如何配置？工作原理？</strong></p>
<p>Tree-shaking，即消除那些被<strong>引用了但未被使用</strong>的模块代码。</p>
<p>想要对代码进行 tree-shaking，首先必须处于生产模式。Webpack 只有在压缩代码的时候会 tree-shaking，而这只会发生在生产模式中。</p>
<p>其次，需要采用 ES6 模块化语法，tree-shaking 是静态编译时优化，使用 commonJS 的模块无法被分析。</p>
<p>随着 Webpack4.0 采用约定高于配置的理念，在 mode 为 <code>production</code> 的情况默认开启优化配置项。</p>
<p>默认使用的是 terser-webpack-plugin 压缩插件，在此之前是使用 uglifyjs-webpack-plugin，其中的区别是内置对 ES6 的压缩不是很好。</p>
<p>注意默认情况下，所有的模块都会被认为是有副作用的，Tree Shaking 不能删除带副作用的代码。所以，webpack 提供了 sideEffects 这个配置，在 package.json 中将这个配置设置为 false，意思就是 webpack 认为所有文件都是没有副作用的。</p>
<hr>
<p>原理：</p>
<p>Tree Shaking 会分析所有的 es6 module import 和 export，判断哪些是无用的代码，同时为它们打上标记，然后使用压缩工具(TerserPlugin)删除这些冗余的代码。</p>
</li>
<li><p><strong>说说 webpack 的代码分割？解决了哪些问题？</strong></p>
<p>code-spliting 是提高代码使用率的关键技术，即代码分割。代码分割是指，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程。在 Webpack 构建时，会避免加载已声明要异步加载的代码 ，异步代码会被单独分离出一个文件，当代码实际调用时被加载至页面。</p>
<p>可以通过 <code>import()</code> 关键字让浏览器在程序执行时异步加载相关资源。</p>
<p>代码分割也包括静态和动态分割两种。</p>
<p>静态代码分割是指，<strong>在代码中明确声明需要异步加载的代码</strong>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> Listener <span class="token keyword">from</span> <span class="token string">'./listeners.js'</span>
<span class="token keyword">const</span> <span class="token function-variable function">getModal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./src/modal.js'</span><span class="token punctuation">)</span> 
Listener<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>
  <span class="token string">'didSomethingToWarrentModalBeingLoaded'</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Async fetching modal code from a separate chunk</span>
    <span class="token function">getModal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">const</span> modalTarget <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'Modal'</span><span class="token punctuation">)</span>    
        module<span class="token punctuation">.</span><span class="token function">initModal</span><span class="token punctuation">(</span>modalTarget<span class="token punctuation">)</span>  
      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span></code></pre>

<p>动态代码分割是指：<strong>在代码调用时根据当前的状态，「动态地」异步加载对应的代码块</strong>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">getTheme</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">themeName</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./src/themes/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>themeName<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token comment">// using `import()` 'dynamically'</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>feeling<span class="token punctuation">.</span>stylish<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">getTheme</span><span class="token punctuation">(</span><span class="token string">'stylish'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    module<span class="token punctuation">.</span><span class="token function">applyTheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>feeling<span class="token punctuation">.</span>trendy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">getTheme</span><span class="token punctuation">(</span><span class="token string">'trendy'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    module<span class="token punctuation">.</span><span class="token function">applyTheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>实现了类似 commonJS 的效果。但它们的工作原理却大不相同。实际上 webpack 已经在构建时将所有声明的分割模块分离为一个单独的文件(contextModule)，在调用时和静态分割一样，是在请求一个已经准备好的文件。</p>
</li>
<li><p><strong>什么是 webpack 的作用域提升？为什么要作用域提升？</strong></p>
<p>可以简单地把 Scope Hoisting 理解为把每个模块被 Webpack 处理成模块初始化函数整理到一个统一的包裹函数里，也就是把多个作用域用一个作用域取代，以减少内存消耗并减少包裹块代码，从每个模块有一个包裹函数变成只有一个包裹函数包裹所有的模块。</p>
<p>但是有一个前提就是，当模块的引用次数大于 1 时，比如被引用了两次或以上，那么这个效果会无效，这是因为被引用多次即这个模块代码会被内联多次，从而增加了打包出来的 JS Bundle 体积。也就是被引用多次的模块在被 Webpack 处理后，会被独立的包裹函数所包裹。</p>
<hr>
<p>需要作用域提升的原因：</p>
<ul>
<li>大量函数闭包包裹代码，导致体积增大，模块越多越明显</li>
<li>运行代码时创建的函数作用域变多，内存开销变大</li>
</ul>
</li>
<li><p><strong>SourceMap 有什么用？</strong></p>
<p>Source map 就是一个信息文件，里面储存着代码的位置信息。这种文件主要用于开发调试，现在代码都会经过压缩混淆，这样报错提示会很难定位代码。通过 SourceMap 能快速定位到源代码，并进行调试。</p>
<p>通常情况 SourceMap 在开发环境开启，线上环境关闭。</p>
<p>开发环境推荐：</p>
<p>cheap-module-eval-source-map</p>
<p>生产环境推荐：</p>
<p>cheap-module-source-map 、hidden-source-map</p>
<p>应用场景：</p>
<ul>
<li>开发期间，开发人员能直接通过浏览器调试工具直接定位错误或进行 Debug 调试。</li>
<li>线上排查问题的时候可以将 SourceMap 上传到错误监控系统。</li>
</ul>
</li>
<li><p><strong>如何提高webpack的构建速度？</strong></p>
<p>常见的提升构建速度的手段有如下：</p>
<ul>
<li><p>优化 loader 配置</p>
<p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件，<code>include</code>、<code>exclude</code> 规定哪些匹配应用<code>loader</code>。</p>
</li>
<li><p>合理使用 resolve.extensions</p>
<p>通过<code>resolve.extensions</code> 在解析文件时自动添加拓展名，当我们引入文件的时候，若没有文件后缀名，则会根据数组内的值依次查找，配置的时候，不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度。</p>
</li>
<li><p>优化 resolve.modules</p>
<p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找第三方模块。所以可以指明存放第三方模块的绝对路径，以减少寻找。</p>
</li>
<li><p>优化 resolve.alias</p>
<p><code>alias</code>给一些常用的路径起一个别名，当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式，通过配置<code>alias</code>以减少查找过程。</p>
</li>
<li><p>使用 cache-loader</p>
<p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果缓存到磁盘里，显著提升二次构建速度，保存和读取这些缓存文件会有一些时间开销，所以只对性能开销较大的 <code>loader</code> 使用。</p>
</li>
<li><p>启动多线程</p>
<p>借助一些插件如 HappyPack，使用多进程并行运行来提高构建速度。</p>
</li>
<li><p>合理使用 sourceMap</p>
<p>打包生成 <code>sourceMap</code> 的时候，如果信息越详细，打包速度就会越慢。因此根据实际需要选择最合适的配置。</p>
</li>
</ul>
</li>
<li></li>
</ol>
<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><ol>
<li><p><strong>说说你对Redux的理解？其工作原理？</strong></p>
<p>在 React 应用中存在很多个组件，每个组件的<code>state</code>是由自身进行管理，包括组件定义自身的<code>state</code>、组件之间的通信通过<code>props</code>传递、使用<code>Context</code>实现数据共享。</p>
<p>如果让每个组件都存储自身相关的状态，理论上来讲不会影响应用的运行，但在开发及后续维护阶段，我们将花费大量精力去查询状态的变化过程。这种情况下，如果将所有的状态进行集中管理，当需要更新状态的时候，仅需要对这个管理集中处理，而不用去关心状态是如何分发到每一个组件内部的。</p>
<p><code>redux</code>就是一个实现上述集中管理的容器，遵循三大基本原则：</p>
<ul>
<li>单向数据流</li>
<li>不可变数据</li>
<li>纯函数</li>
</ul>
<hr>
<p>工作原理：</p>
<p>通过在 context 注入一个全局的 store，集中式地管理数据。</p>
<p>为 store 指定 reducer，完成连接。</p>
<p>其内部的 state 对象一旦创建就不可变，更新 state，采用全新的 state 替换原本的 state。</p>
<p>通过 Action Creator 定义不同的 Action，来操作不同的 state。</p>
<p>通过 reducer 的 dispatch 操作，传入 Action 来修改组件内部状态。</p>
</li>
<li><p><strong>你在React项目中是如何使用Redux的? 项目结构是如何划分的？</strong></p>
<p>通过<code>redux</code>将整个应用状态存储到<code>store</code>中，组件可以派发<code>dispatch</code>行为<code>action</code>给<code>store</code>。</p>
<p>其他组件通过订阅<code>store</code>中的状态<code>state</code>来更新自身的视图。</p>
<p>可以根据项目具体情况进行选择，以下列出两种常见的组织结构：</p>
<ul>
<li><p>按角色组织（MVC）</p>
<p>按照代码在项目中的角色定位来组织，如：</p>
<pre class="language-json" data-language="json"><code class="language-json">reducers/
  todoReducer.js
  filterReducer.js
actions/
  todoAction.js
  filterActions.js
components/
  todoList.js
  todoItem.js
  filter.js
containers/
  todoListContainer.js
  todoItemContainer.js
  filterContainer.js</code></pre></li>
<li><p>按功能组织</p>
<p>把完成同一功能的代码放在一个目录下，一个应用功能包含多个角色的代码。如：</p>
<pre class="language-json" data-language="json"><code class="language-json">todoList/
  actions.js
  actionTypes.js
  index.js
  reducer.js
  views/
    components.js
    containers.js
filter/
  actions.js
  actionTypes.js
  index.js
  reducer.js
  views/
    components.js
    container.js</code></pre></li>
</ul>
</li>
<li><p><strong>说说对Redux中间件的理解？常用的中间件有哪些？实现原理？</strong></p>
<p>中间件(Middleware)是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务，衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p>
<p>Redux 中如果需要支持异步操作，或者支持错误处理、日志监控，这个过程就可以用上中间件，中间件就是放在就是在 <code>dispatch</code> 过程，在分发 <code>action</code> 时进行拦截处理。</p>
<p>本质上是一个函数，在内部对 store.dispatch 进行了封装，在发出 action 和执行 reducer 之间，添加了一些额外的操作。</p>
<p>常用的中间件有：</p>
<ul>
<li>redux-thunk：用于异步操作</li>
<li>redux-logger：用于日志记录</li>
</ul>
<p>上述的中间件都需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行</p>
<p>然后作为第二个参数传入到<code>createStore</code>中。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>
  reducer<span class="token punctuation">,</span>
  <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>thunk<span class="token punctuation">,</span> logger<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<hr>
<p>实现原理：</p>
<p>看看<code>applyMiddlewares</code>的源码：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">applyMiddleware</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>middlewares</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter">createStore</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">reducer<span class="token punctuation">,</span> preloadedState<span class="token punctuation">,</span> enhancer</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> store <span class="token operator">=</span> <span class="token function">createStore</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> preloadedState<span class="token punctuation">,</span> enhancer<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> dispatch <span class="token operator">=</span> store<span class="token punctuation">.</span>dispatch<span class="token punctuation">;</span>
    <span class="token keyword">var</span> chain <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> middlewareAPI <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
      getState<span class="token operator">:</span> store<span class="token punctuation">.</span>getState<span class="token punctuation">,</span>
      <span class="token function-variable function">dispatch</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">dispatch</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    chain <span class="token operator">=</span> middlewares<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">middleware</span> <span class="token operator">=></span> <span class="token function">middleware</span><span class="token punctuation">(</span>middlewareAPI<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    dispatch <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token operator">...</span>chain<span class="token punctuation">)</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span>dispatch<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span>store<span class="token punctuation">,</span> dispatch<span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>所有中间件被放进了一个数组<code>chain</code>，然后遍历执行，最后将所有的中间件组合成一个函数，传入 <code>store.dispatch</code>。</p>
</li>
<li><p><strong>了解过 Redux-thunk 吗？能不能手动实现？</strong></p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createThunkMiddleware</span><span class="token punctuation">(</span><span class="token parameter">extraArgument</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span> dispatch<span class="token punctuation">,</span> getState <span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">next</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> <span class="token function">action</span><span class="token punctuation">(</span>dispatch<span class="token punctuation">,</span> getState<span class="token punctuation">,</span> extraArgument<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> thunk <span class="token operator">=</span> <span class="token function">createThunkMiddleware</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thunk<span class="token punctuation">.</span>withExtraArgument <span class="token operator">=</span> createThunkMiddleware<span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> thunk<span class="token punctuation">;</span></code></pre>

<p>从源码来看，redux-thunk 非常简单。如果传入的 action 是函数，就直接执行它，并传入 dispatch 等作为参数。在 action 函数内部，就可以在异步代码中执行 dispatch 了。</p>
</li>
</ol>
<h2 id="项目性能优化"><a href="#项目性能优化" class="headerlink" title="项目性能优化"></a>项目性能优化</h2><ol>
<li><p><strong>说说如何借助webpack来优化前端性能？</strong></p>
<p>通过<code>webpack</code>优化前端的手段有：</p>
<ul>
<li><p>JS 代码压缩</p>
<p>比较常用的 uglifyjs-webpack-plugin、TerserPlugin 都是对 JS 文件进行压缩处理。</p>
</li>
<li><p>CSS 代码压缩</p>
<p>css-minimizer-webpack-plugin，通常是去除无用的空格。optimize-css-assets-webpack-plugin 可以对 css 进行去重。</p>
</li>
<li><p>HTML 代码压缩</p>
<p>使用 HtmlWebpackPlugin 插件来生成 HTML 模板时，通过配置属性 minify 进行 html 优化。</p>
</li>
<li><p>文件大小压缩</p>
<p>ComepressionPlugin，减少文件体积，减少 http 传输过程中的损耗。</p>
</li>
<li><p>图片大小压缩</p>
<p>在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要大，所以图片压缩较为重要。</p>
<p>可在 image-webpack-loader 中配置不同格式的图片压缩，或者 url-loader 将较小的图片转换为 base64 编码。</p>
</li>
<li><p>Tree Shaking</p>
<p>实现 Tree shaking 有两种不同的方案：</p>
<p>usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化</p>
<p>sideEffects：webpack 将认为整个文件无副作用，完全移除所有未使用的代码。</p>
</li>
<li><p>代码分割</p>
<p>默认情况下，所有的 JavaScript 代码(业务代码、第三方依赖、暂时没有用到的模块)在首页全部都加载，就会影响首页的加载速度。</p>
<p>将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件。</p>
<p>代码分离可以分出更小的 bundle，以及控制资源加载优先级，提供代码的加载性能。</p>
</li>
<li><p>作用域提升</p>
<p>把一些包裹模块的独立函数整合到一个统一的包裹函数中，以减少内存消耗并减少包裹块代码。</p>
</li>
</ul>
</li>
<li><p><strong>谈谈你对编码优化的理解？</strong></p>
<p>编码优化，指的就是 在代码编写时，通过一些最佳实践，提升代码的执行性能。通常这并不会带来非常大的收益，但这属于程序猿的自我修养。</p>
<hr>
<p><strong>循环</strong>: 通常是编码性能的关键点，代码的性能问题会再循环中被指数倍放大。</p>
<ul>
<li>尽可能 减少循环次数，包括<strong>减少遍历的数据量</strong>，完成目的后立即<strong>终止循环</strong>。</li>
<li>避免在循环中执行大量的运算，避免重复计算，相同的执行结果应该使用<strong>缓存</strong>。</li>
<li>尽量<strong>避免使用 for-in 循环</strong>，因为它会枚举原型对象，耗时大于普通循环。</li>
</ul>
<hr>
<p><strong>条件流程性能</strong>: Map / Object &gt; switch &gt; if-else</p>
<hr>
<p><strong>数据读取</strong>:</p>
<ul>
<li>尽量在局部作用域中进行<strong>变量缓存。</strong></li>
<li>避免嵌套过深的数据结构，<strong>数据扁平化</strong> 有利于数据的读取和维护。</li>
</ul>
<hr>
<p><strong>dom 优化</strong>:</p>
<ul>
<li><strong>减少访问 dom 的次数</strong>，如需多次，将 dom 缓存，如 useRef。</li>
<li><strong>减少重绘与回流</strong>，多次操作合并为一次，减少对计算属性的访问。大量操作时，可将 dom 脱离文档流或者隐藏，待操作完成后再重新恢复。</li>
<li><strong>使用事件委托</strong>，避免大量的事件绑定。</li>
</ul>
<hr>
<p><strong>css 优化</strong>:</p>
<ul>
<li><strong>层级扁平</strong>，避免过于多层级的选择器嵌套。</li>
<li><strong>特定的选择器</strong> 好过一层一层查找: <code>.xxx-child-text&#123;&#125;</code> 优于 <code>.xxx .child .text&#123;&#125;</code></li>
<li><strong>减少使用通配符与属性选择器</strong>。</li>
<li><strong>减少不必要的多余属性</strong>。</li>
<li>使用 <strong>动画属性</strong> 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画。</li>
<li>使用 <code>&lt;link&gt;</code> 替代原生 <code>@import</code>。</li>
</ul>
<hr>
<p><strong>html 优化</strong>:</p>
<ul>
<li><strong>减少 dom 数量</strong>，避免不必要的节点或嵌套。</li>
<li><strong>避免<code>&lt;img src=&quot;&quot; /&gt;</code>空标签</strong>，能减少服务器压力，因为 src 为空时，浏览器仍然会发起请求。</li>
<li>图片提前 <strong>指定宽高</strong> 或者 <strong>脱离文档流</strong>，能有效减少因图片加载导致的页面回流。</li>
<li><strong>语义化标签</strong> 有利于 SEO 与浏览器的解析时间。</li>
<li><strong>减少使用 table</strong> 进行布局，避免使用<code>&lt;br/&gt;</code>与<code>&lt;hr/&gt;</code></li>
</ul>
</li>
<li><p><strong>在页面的基础上可以做哪些优化？</strong></p>
<p><strong>引入位置</strong>：</p>
<ul>
<li>css 文件<code>&lt;head&gt;</code>中引入， js 文件<code>&lt;body&gt;</code>底部引入。</li>
<li>影响首屏的，优先级很高的 js 也可以头部引入，甚至内联。</li>
</ul>
<hr>
<p><strong>减少请求(http 1.0 - 1.1)：</strong></p>
<ul>
<li>合并请求，正确设置 http 缓存。</li>
</ul>
<hr>
<p><strong>减少文件体积</strong>:</p>
<ul>
<li><strong>删除多余代码</strong>，tree-shaking，UglifyJs 等。</li>
<li><strong>混淆 / 压缩代码</strong>，开启 gzip 压缩。</li>
<li><strong>多份编译文件按条件引入</strong>，针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件。</li>
<li><strong>动态 polyfill</strong>，只针对不支持的浏览器引入 polyfill。</li>
</ul>
<hr>
<p><strong>图片优化</strong>:</p>
<ul>
<li>根据业务场景，与 UI 探讨选择<strong>合适质量，合适尺寸</strong>。</li>
<li>根据需求和平台，选择<strong>合适格式</strong>，例如非透明时可用 jpg；非 IOS 端，使用 webp。</li>
<li>小图片合成<strong>雪碧图</strong>，低于 5K 的图片可以转换成 <strong>base64</strong> 内嵌。</li>
<li>合适场景下，使用 <strong>iconfont</strong> 或者 <strong>svg</strong>。</li>
</ul>
<hr>
<p><strong>使用缓存</strong>:</p>
<ul>
<li><strong>浏览器缓存</strong>，通过设置请求的过期时间，合理运用浏览器缓存。</li>
<li><strong>CDN缓存</strong>，静态文件合理使用 CDN 缓存技术。</li>
<li><strong>服务器缓存</strong>，将不变的数据、页面缓存到内存或远程存储(redis等)上。</li>
<li><strong>数据缓存</strong>: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间。</li>
</ul>
</li>
<li><p><strong>首屏渲染优化有哪些方式？</strong></p>
<p><strong>加载优化：</strong></p>
<ul>
<li><strong>代码分割</strong>，使首屏依赖的文件体积最小。</li>
<li>非关键性的文件尽可能的<strong>异步加载和懒加载</strong>，避免阻塞首屏渲染。</li>
<li>使用<code>dns-prefetch / preconnect / prefetch / preload</code>等浏览器提供的资源提示，加快文件传输。</li>
<li>谨慎控制好 <strong>Web字体</strong>，控制字体包的加载时机，如果使用的字体有限，那尽可能只将使用的文字单独打包，能有效减少体积。</li>
<li>合理利用 Localstorage / server-worker 等存储方式进行 <strong>数据与资源缓存</strong>。</li>
</ul>
<hr>
<p><strong>顺序优化：</strong></p>
<ul>
<li><strong>分清轻重缓急</strong>，重要的元素优先渲染，视窗内的元素优先渲染。</li>
</ul>
<hr>
<p><strong>用户感知优化：</strong></p>
<ul>
<li>利用一些动画<strong>过渡效果</strong>，能有效减少用户对卡顿的感知</li>
<li>尽可能利用<strong>骨架屏(Placeholder) / Loading</strong> 等减少用户对白屏的感知。</li>
<li>动画帧数尽量保证在<strong>30帧</strong>以上，低帧数、卡顿的动画宁愿不要。</li>
<li>js 执行时间避免超过 <strong>100ms</strong>，寻找可缓存的点，任务分割异步或 web worker 执行。</li>
</ul>
<hr>
<p><strong>服务端渲染(SSR)：</strong></p>
<ul>
<li>减少首屏需要的数据量，剔除冗余数据和请求。</li>
<li>控制好缓存，对数据/页面进行合理的缓存。</li>
<li>页面的请求使用流的形式进行传递。</li>
</ul>
</li>
<li><p><strong>知道哪些性能优化的指标？</strong></p>
<p>资源加载：</p>
<p>chrome 瀑布图，打开 NetWork，</p>
</li>
<li></li>
</ol>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>待续。</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sticla</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://blog.sticla.top/2021/08/20/front-end-interview-review-tools/" title="备战前端面试--工具与优化篇">https://blog.sticla.top/2021/08/20/front-end-interview-review-tools/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/09/10/interview-review-mind/" rel="prev" title="备战前端面试--前端知识体系"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">备战前端面试--前端知识体系</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/08/18/front-end-interview-review-react/" rel="next" title="备战前端面试--react篇"><span class="post-nav-text">备战前端面试--react篇</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/li-sticla/li-sticla.github.io/issues?q=is:issue+备战前端面试--工具与优化篇">GitHub Issues</a></div><div id="valine-container"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js", () => {
  const valineConfig = {"enable":true,"appId":"fhhkJbCVeplMMyPTL5CmiGOV-MdYXbMMI","appKey":"gXz6Ktd45hdMO77EYNY9cRds","placeholder":"有任何问题请留言，看到会回复滴","avatar":null,"pageSize":10,"visitor":true,"highlight":true,"recordIP":false,"enableQQ":true,"avatar_cdn":"https://gravatar.loli.net/avatar/","meta":["nick","mail","link"],"el":"#valine-container","lang":"en"}
  valineConfig.path = "/2021/08/20/front-end-interview-review-tools/"
  new Valine(valineConfig)
}, window.Valine);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sticla</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.2</span></div><div class="live_time"><span>本博客已萌萌哒地存活了</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-03-19T21:17:49');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>