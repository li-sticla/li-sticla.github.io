<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#6200ee"><meta name="author" content="sticla"><meta name="copyright" content="sticla"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>备战前端面试--js-web-api篇 | sticla studio</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#6200ee"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"blog.sticla.top","root":"/","title":"sticla studio","version":"1.5.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-CCS65Z3P4C"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-CCS65Z3P4C');
}</script><meta name="description" content="备战前端面试—JS-Web-API篇AjaxXHR 的概念考点1：XHR 对象 XHR 是什么？ XHR(XMLHttpRequest)即 XMLHttpRequest 对象。 XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。它可以操作任何数据，而不仅仅是 XML 格式。XMLHttpRequest 可以">
<meta property="og:type" content="article">
<meta property="og:title" content="备战前端面试--js-web-api篇">
<meta property="og:url" content="https://blog.sticla.top/2021/08/13/front-end-interview-review-js-web-api/index.html">
<meta property="og:site_name" content="sticla studio">
<meta property="og:description" content="备战前端面试—JS-Web-API篇AjaxXHR 的概念考点1：XHR 对象 XHR 是什么？ XHR(XMLHttpRequest)即 XMLHttpRequest 对象。 XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。它可以操作任何数据，而不仅仅是 XML 格式。XMLHttpRequest 可以">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-08-13T12:06:25.000Z">
<meta property="article:modified_time" content="2023-02-02T06:23:29.266Z">
<meta property="article:author" content="sticla">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info mickey-mouse"><a class="site-author-avatar" href="/about/" title="sticla"><img width="96" loading="lazy" src="https://cdn.jsdelivr.net/gh/li-sticla/picBed@latest/EAXX2-BUwAA2FuM (2).jpg" alt="sticla"><span class="site-author-status" title="我爱摸鱼">😭</span></a><div class="site-author-name"><a href="/about/">sticla</a></div><span class="site-name">sticla studio</span><sub class="site-subtitle">Change the world！</sub><div class="site-desciption">只有弱者才睡觉！</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">20</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/li-sticla" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:yuanzichao@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1619244804" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/5050630" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/sticla_yuuri" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/sticla" title="Telegram" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%87%E6%88%98%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94JS-Web-API%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">备战前端面试—JS-Web-API篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">1.1.</span> <span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XHR-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">XHR 的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9AXHR-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">考点1：XHR 对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AJAX-%E7%9A%84%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">AJAX 的相关应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A-jQuery-Ajax"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">考点1： jQuery Ajax</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9AFetch-API"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">考点2：Fetch API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B93%EF%BC%9AAxios"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">考点3：Axios</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM"><span class="toc-number">1.2.</span> <span class="toc-text">DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">DOM 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9ADOM-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">考点1：DOM 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%B8%B2%E6%9F%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">DOM 渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9ADOM-%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">考点1：DOM 渲染方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E9%A6%96%E5%B1%8F%E5%92%8C%E7%99%BD%E5%B1%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">考点2：首屏和白屏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">DOM 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9A%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">考点1：事件与事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">考点2：事件模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BOM"><span class="toc-number">1.3.</span> <span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">BOM 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9ABOM-%E4%B8%8E-DOM"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">考点1：BOM 与 DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9A%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">考点2：页面生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">BOM 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B91%EF%BC%9AWindow-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">考点1：Window 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B92%EF%BC%9ALocation-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">考点2：Location 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%83%E7%82%B93%EF%BC%9AHistory-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">考点3：History 对象</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://blog.sticla.top/2021/08/13/front-end-interview-review-js-web-api/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="sticla"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="sticla studio"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">备战前端面试--js-web-api篇</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-08-13 12:06:25" itemprop="dateCreated datePublished" datetime="2021-08-13T12:06:25+00:00">2021-08-13</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2023-02-02 06:23:29" itemprop="dateModified" datetime="2023-02-02T06:23:29+00:00">2023-02-02</time></div><span class="leancloud_visitors" id="/2021/08/13/front-end-interview-review-js-web-api/" data-flag-title="备战前端面试--js-web-api篇"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%AD%A6%E4%B9%A0-JavaScript/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学习-JavaScript</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/JavaScript/" style="--text-color:#F4DF4F"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">JavaScript</span></a><a class="tag" href="/tags/interview/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">interview</span></a></span></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/429930d44169a040b9b3a3e187e2f63e?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">sticla</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#6200ee;"><h1 id="备战前端面试—JS-Web-API篇"><a href="#备战前端面试—JS-Web-API篇" class="headerlink" title="备战前端面试—JS-Web-API篇"></a>备战前端面试—JS-Web-API篇</h1><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="XHR-的概念"><a href="#XHR-的概念" class="headerlink" title="XHR 的概念"></a>XHR 的概念</h3><h4 id="考点1：XHR-对象"><a href="#考点1：XHR-对象" class="headerlink" title="考点1：XHR 对象"></a>考点1：XHR 对象</h4><ol>
<li><p><strong>XHR 是什么？</strong></p>
<p><code>XHR(XMLHttpRequest)</code>即 XMLHttpRequest 对象。</p>
<p>XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。它可以操作任何数据，而不仅仅是 XML 格式。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。</p>
</li>
<li><p><strong>XHR 提供了哪些常用的方法？</strong></p>
<p>XHR 分为同步和异步模式。</p>
<p><strong>异步模式：</strong></p>
<pre class="language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>async<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>

<p>此方法指定了请求的主要参数：</p>
<ul>
<li>method：请求的方法，限定为 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 之一。</li>
<li>URL：要请求的 url。通常是字符串，也可以是 url 对象(如果有搜索参数，避免转码问题)。</li>
<li>async：如果显示地设定为 false，将采用同步模式。</li>
<li>user，password：HTTP 基本身份验证（如果需要的话）的登录名和密码。</li>
</ul>
<p>发送请求：</p>
<pre class="language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">[</span>body<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>

<p>body：可选参数，请求体。</p>
<p>之后需要监听 XHR 事件，以作出响应：</p>
<p>这三个事件是最常用的：</p>
<ul>
<li>load：当请求完成(<code>200</code>、<code>500</code>)，并且响应已完全下载。</li>
<li>error：当无法发送请求，如网络中断、URL 无效。</li>
<li>progress：在下载期间定期触发，报告当前进度。</li>
</ul>
<p>一旦有了结果，可以从 XHR 的以下属性中获得结果：</p>
<ul>
<li>status：HTTP 状态码（一个数字）：<code>200</code>，<code>404</code>，<code>403</code> 等，如果出现非 HTTP 错误，则为 <code>0</code>。</li>
<li>statusText：HTTP 状态消息（一个字符串）：状态码为 <code>200</code> 对应于 <code>OK</code>，<code>404</code> 对应于 <code>Not Found</code>，<code>403</code> 对应于 <code>Forbidden</code>。</li>
<li>response：服务器的响应体。</li>
</ul>
<p>可以设置超时时间，如果给定时间内请求没有成功执行，请求就会取消，同时触发 timeout 事件：</p>
<pre class="language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span>timeout <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token comment">// timeout 单位是 ms，此处即 10 秒</span></code></pre>

<p>我们可以使用 <code>xhr.responseType</code> 属性来设置响应格式：</p>
<ul>
<li><code>&quot;&quot;</code>（默认）—— 响应格式为字符串，</li>
<li><code>&quot;text&quot;</code> —— 响应格式为字符串，</li>
<li><code>&quot;arraybuffer&quot;</code> —— 响应格式为 <code>ArrayBuffer</code></li>
<li><code>&quot;blob&quot;</code> —— 响应格式为 <code>Blob</code></li>
<li><code>&quot;document&quot;</code> —— 响应格式为 XML document（可以使用 XPath 和其他 XML 方法），</li>
<li><code>&quot;json&quot;</code> —— 响应格式为 JSON（自动解析）。</li>
</ul>
<p>我们可以随时终止请求。调用 <code>xhr.abort()</code> 即可。</p>
<hr>
<p><strong>同步请求：</strong></p>
<p>如果在 <code>open</code> 方法中将第三个参数 <code>async</code> 设置为 <code>false</code>，那么请求就会以同步的方式进行。</p>
<p>JS 脚本将在 <code>send()</code> 处暂停，并在收到响应后恢复执行。这会阻塞页面加载。基于这些原因，同步请求使用的非常少，几乎从不使用。</p>
</li>
</ol>
<h3 id="AJAX-的相关应用"><a href="#AJAX-的相关应用" class="headerlink" title="AJAX 的相关应用"></a>AJAX 的相关应用</h3><h4 id="考点1：-jQuery-Ajax"><a href="#考点1：-jQuery-Ajax" class="headerlink" title="考点1： jQuery Ajax"></a>考点1： jQuery Ajax</h4><ol>
<li><p><strong>什么是 Ajax？如何使用？</strong></p>
<p><code>AJAX(Async Javascript and XML)</code></p>
<p>即异步的<code>JavaScript</code> 和<code>XML</code>，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页。</p>
<p>jquery 的 ajax：</p>
<pre class="language-js" data-language="js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
   type<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>
   url<span class="token operator">:</span> url<span class="token punctuation">,</span>
   data<span class="token operator">:</span> data<span class="token punctuation">,</span>
   dataType<span class="token operator">:</span> dataType<span class="token punctuation">,</span>
   <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
   <span class="token function-variable function">error</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong>Ajax 的原理是什么？如何实现？</strong></p>
<p><strong>ajax 原理</strong>简单来说是通过 XHR 对象向服务器发送异步请求，同时在接收到响应后，使用 JS 操作 DOM 更新页面。</p>
<p><strong>实现过程：</strong></p>
<ol>
<li><p>创建核心对象 XHR</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li>
<li><p>通过 XHR 的 open 方法与服务器建立连接</p>
<pre class="language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token punctuation">[</span>async<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span> user<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">,</span> password<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li>
<li><p>构建请求所需的内容，通过 send 方法将请求发送给服务器</p>
<pre class="language-js" data-language="js"><code class="language-js">xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">[</span>body<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li>
<li><p>通过 XHR 对象的 onreadystatechange 事件监听服务端通信状态</p>
<p>关于<code>XMLHttpRequest.readyState</code>属性有五个状态：</p>
<p>0：UNSET，未打开，open 方法还未调用</p>
<p>1：OPEND，未发送，send 方法还未调用</p>
<p>2：HEADERS_RECEIVED，已获取响应头，服务端已返回响应头和响应状态</p>
<p>3：LOADING，下载响应体，响应体下载中，responseText 已获取部分内容</p>
<p>4：DONE，请求结束，整个请求过程完毕</p>
</li>
<li><p>接收并处理服务端响应的数据结果</p>
</li>
<li><p>将处理结果更新到 <code>HTML</code>页面中</p>
</li>
</ol>
<p>封装以后的 ajax 代码：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//初始化配置</span>
  options <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  options<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>type <span class="token operator">||</span> <span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  options<span class="token punctuation">.</span>dataType <span class="token operator">=</span> options<span class="token punctuation">.</span>dataType <span class="token operator">||</span> <span class="token string">"json"</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> params <span class="token operator">=</span> options<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token comment">//发送请求</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">"GET"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>url <span class="token operator">+</span> <span class="token string">"?"</span> <span class="token operator">+</span> params<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">"POST"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"POST"</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token comment">//接收请求</span>
  xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//请求完成</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">let</span> status <span class="token operator">=</span> xhr<span class="token punctuation">.</span>status<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        options<span class="token punctuation">.</span>success <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">,</span> xhr<span class="token punctuation">.</span>responseXML<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        options<span class="token punctuation">.</span>error <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  type<span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>
  dataType<span class="token operator">:</span> <span class="token string">"json"</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  url<span class="token operator">:</span> <span class="token string">"https://xxxxx"</span><span class="token punctuation">,</span>
  <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">error</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ol>
<h4 id="考点2：Fetch-API"><a href="#考点2：Fetch-API" class="headerlink" title="考点2：Fetch API"></a>考点2：Fetch API</h4><ol>
<li><p><strong>什么是 fetch？如何使用？</strong></p>
<p>fetch 是脱离了 XHR 的全新 API，是 ajax 的替代方案。解决了 ajax 在使用时必须引入 jQuery 的缺陷，并且是基于 Promise 的实现，符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里，更加人性化，同时写法简单方便。</p>
<p>优势：</p>
<ul>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了 XHR，是ES规范里新的实现方式</li>
<li>支持 async/await 以书写同步代码的方式完成异步操作</li>
</ul>
<p>缺点：</p>
<ul>
<li>是一个低层次的 API，使用时仍然需要封装。</li>
<li>默认不带 cookie，需要进行设置。</li>
<li>只有网络错误能得到处理，服务器返回错误码时不会 reject。</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// Example POST method implementation:</span>

<span class="token function">postData</span><span class="token punctuation">(</span><span class="token string">'http://example.com/answer'</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>answer<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// JSON from `response.json()` call</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">postData</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// Default options are marked with *</span>
  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>
    body<span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// must match 'Content-Type' header</span>
    cache<span class="token operator">:</span> <span class="token string">'no-cache'</span><span class="token punctuation">,</span> <span class="token comment">// *default, no-cache, reload, force-cache, only-if-cached</span>
    credentials<span class="token operator">:</span> <span class="token string">'same-origin'</span><span class="token punctuation">,</span> <span class="token comment">// include, same-origin, *omit</span>
    headers<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      <span class="token string">'user-agent'</span><span class="token operator">:</span> <span class="token string">'Mozilla/4.0 MDN Example'</span><span class="token punctuation">,</span>
      <span class="token string">'content-type'</span><span class="token operator">:</span> <span class="token string">'application/json'</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token comment">// *GET, POST, PUT, DELETE, etc.</span>
    mode<span class="token operator">:</span> <span class="token string">'cors'</span><span class="token punctuation">,</span> <span class="token comment">// no-cors, cors, *same-origin</span>
    redirect<span class="token operator">:</span> <span class="token string">'follow'</span><span class="token punctuation">,</span> <span class="token comment">// manual, *follow, error</span>
    referrer<span class="token operator">:</span> <span class="token string">'no-referrer'</span><span class="token punctuation">,</span> <span class="token comment">// *client, no-referrer</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// parses response to JSON</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ol>
<h4 id="考点3：Axios"><a href="#考点3：Axios" class="headerlink" title="考点3：Axios"></a>考点3：Axios</h4><ol>
<li><p><strong>什么是 axios？如何使用？</strong></p>
<p>axios 是对原生 XHR 的封装，ajax 的另一个替代方案。同时也是 Promise 的实现版本，符合最新 ES 规范。可用于 NodeJS 和浏览器。</p>
<p>有以下几条特性：</p>
<ul>
<li>在浏览器中创建 XMLHttpRequests</li>
</ul>
<ul>
<li>在 node.js 中直接创建 http 请求</li>
<li>支持 Promise API</li>
<li>支持拦截请求和响应</li>
<li>客户端支持防止CSRF(让你的每个请求都带一个从 cookie 中拿到的key)</li>
<li><strong>提供了一些并发请求的接口</strong></li>
</ul>
<p>使用上也简化了，更加灵活：</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
  url<span class="token operator">:</span> <span class="token string">'http://api.com'</span><span class="token punctuation">,</span>
  method<span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>
  header<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string">'Content-Type'</span><span class="token operator">:</span> <span class="token string">'application/json'</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
  data<span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    name<span class="token operator">:</span> <span class="token string">'John'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">22</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">axios</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ol>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><h4 id="考点1：DOM-方法"><a href="#考点1：DOM-方法" class="headerlink" title="考点1：DOM 方法"></a>考点1：DOM 方法</h4><ol>
<li><p><strong>常用的原生 DOM 操作方法有哪些？</strong></p>
<p><strong>创建节点：</strong></p>
<ul>
<li><p><code>createElement</code>：创建新元素</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> divEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><code>createTextNode</code>：创建文本节点</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> textEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">"content"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><code>createDocumentFragment</code>：创建文档碎片，是更轻量级的文档</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> fragment <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createDocumentFragment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><code>createAttribute</code>：创建属性节点，可以是自定义属性</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> dataAttribute <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createAttribute</span><span class="token punctuation">(</span><span class="token string">'custom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>
<p><strong>查询节点：</strong></p>
<ul>
<li><p><code>querySelector</code>：传入有效的 css 选择器，即可选中首个 DOM 元素</p>
<pre class="language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.element'</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#element'</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'[name="username"]'</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'div + p > span'</span><span class="token punctuation">)</span></code></pre></li>
<li><p><code>querySelectorAll</code>：返回一个包含节点子树内所有匹配的元素节点列表，没有则返回空列表。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> container <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">"#test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> matches <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"div.highlighted > p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><code>getElementsBy系列</code>：</p>
<pre class="language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'id属性值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回拥有指定id的对象的引用</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">'class属性值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回拥有指定class的对象集合</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'标签名'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回拥有指定标签名的对象集合</span>
document<span class="token punctuation">.</span><span class="token function">getElementsByName</span><span class="token punctuation">(</span><span class="token string">'name属性值'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回拥有指定名称的对象结合</span></code></pre></li>
</ul>
<p><strong>更新节点：</strong></p>
<ul>
<li><p><code>innerHTML</code>：可修改节点内部的子树</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 获取&lt;p id="p">...&lt;/p ></span>
<span class="token keyword">var</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置文本为abc:</span>
p<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'ABC'</span><span class="token punctuation">;</span> <span class="token comment">// &lt;p id="p">ABC&lt;/p ></span>
<span class="token comment">// 设置HTML:</span>
p<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'ABC &lt;span style="color:red">RED&lt;/span> XYZ'</span><span class="token punctuation">;</span>
<span class="token comment">// &lt;p>...&lt;/p >的内部结构已修改</span></code></pre></li>
<li><p><code>innerText、textContent</code>：自动对文本进行 HTML 编码</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 获取&lt;p id="p-id">...&lt;/p ></span>
<span class="token keyword">var</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p-id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置文本:</span>
p<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'&lt;script>alert("Hi")&lt;/script>'</span><span class="token punctuation">;</span>
<span class="token comment">// HTML被自动编码，无法设置&lt;script>节点:</span>
<span class="token comment">// &lt;p id="p-id">&amp;lt;script&amp;gt;alert("Hi")&amp;lt;/script&amp;gt;&lt;/p ></span></code></pre>

<p>两者的区别在于读取属性时，<code>innerText</code>不返回隐藏元素的文本，而<code>textContent</code>返回所有文本</p>
</li>
<li><p><code> style</code>：<code>DOM</code>节点的<code>style</code>属性对应所有的<code>CSS</code>，可以直接获取或设置。遇到<code>-</code>需要转化为驼峰命名</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 获取&lt;p id="p-id">...&lt;/p ></span>
<span class="token keyword">const</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'p-id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置CSS:</span>
p<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">'#ff0000'</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token string">'20px'</span><span class="token punctuation">;</span> <span class="token comment">// 驼峰命名</span>
p<span class="token punctuation">.</span>style<span class="token punctuation">.</span>paddingTop <span class="token operator">=</span> <span class="token string">'2em'</span><span class="token punctuation">;</span></code></pre></li>
</ul>
<p><strong>添加节点</strong>：</p>
<ul>
<li><p><code>innerHTML</code>：如果是空节点，会添加新节点。否则会直接替换掉原来的所有子节点</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
div<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'&lt;span>child&lt;/span>'</span></code></pre></li>
<li><p><code>appendChild</code>：把一个子节点添加到父节点的末尾，如果该节点已存在，会先删除再插入</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">const</span> haskell <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
haskell<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token string">'haskell'</span><span class="token punctuation">;</span>
haskell<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'Haskell'</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>haskell<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><code>insertBefore</code>：把子节点插入到父节点中指定的节点之前</p>
<pre class="language-js" data-language="js"><code class="language-js">parentElement<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newElement<span class="token punctuation">,</span> referenceElement<span class="token punctuation">)</span></code></pre></li>
<li><p><code> setAttribute</code>：在指定元素中添加一个属性节点，如果元素中已有该属性改变属性值</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span>
div<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'white'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第一个参数属性名，第二个参数属性值。</span></code></pre></li>
</ul>
<p><strong>删除节点：</strong></p>
<ul>
<li><p><code>removeChild</code>：首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把它删掉</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 拿到待删除节点:</span>
<span class="token keyword">const</span> self <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'to-be-removed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 拿到父节点:</span>
<span class="token keyword">const</span> parent <span class="token operator">=</span> self<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
<span class="token comment">// 删除:</span>
<span class="token keyword">const</span> removed <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
removed <span class="token operator">===</span> self<span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>

<p>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置。</p>
</li>
</ul>
</li>
</ol>
<h3 id="DOM-渲染"><a href="#DOM-渲染" class="headerlink" title="DOM 渲染"></a>DOM 渲染</h3><h4 id="考点1：DOM-渲染方式"><a href="#考点1：DOM-渲染方式" class="headerlink" title="考点1：DOM 渲染方式"></a>考点1：DOM 渲染方式</h4><ol>
<li><p><strong>什么是 SPA？与传统 web 开发有什么区别？</strong></p>
<p><code>SPA(single page application)</code>即单页面应用。是一种客户端渲染方式。服务端返回宿主 html 模板，再由 JS 操作 DOM 渲染页面，请求数据。</p>
<p>传统 web 开发，网页内容在服务端渲染完成，⼀次性传输到浏览器。</p>
<p><code>SPA</code> 在用户的角度提供了更优秀的交互体验，从开发者的角度上也减少了代码编写的工作量，提高了工作效率。目前主流的网站开发方式均为 <code>SPA</code>。</p>
</li>
<li><p><strong>什么是 SSR？SSR 解决了什么问题？</strong></p>
<p><code>SSR(server-side rendering)</code>即服务端渲染，指由服务端完成 html 结构的拼接，发送到浏览器，再将其激活(为其绑定状态与事件)成为可交互页面的过程。</p>
<p>由后端渲染首屏 dom 结构后返回，前端拿到首屏结构及 <code>SPA</code> 结构，应用激活后仍按 <code>SPA</code> 方式运行。</p>
<p><code>SSR </code> 在 <code>SPA</code> 的基础上进行改良，主要解决了以下问题：</p>
<ul>
<li><code>seo</code>。搜索引擎优先爬取页面 html 结构，使用 <code>SSR</code> 时，服务端已经生成了业务相关的 html，有利于 <code>seo</code>。</li>
<li>首屏直接渲染。用户无需等待所有 JS 加载，由服务端返回首屏页面。</li>
</ul>
<p>同时也存在缺点：</p>
<ul>
<li>增加项目复杂度</li>
<li>库的支持不友好</li>
<li>代码兼容问题</li>
<li>服务端负载变大</li>
</ul>
</li>
</ol>
<h4 id="考点2：首屏和白屏"><a href="#考点2：首屏和白屏" class="headerlink" title="考点2：首屏和白屏"></a>考点2：首屏和白屏</h4><ol>
<li><p><strong>首屏和白屏是什么？如何计算？</strong></p>
<p><strong>白屏时间：</strong></p>
<p>从输入 URL 到浏览器开始渲染<code>&lt;body&gt;</code>标签或者解析完<code>&lt;head&gt;</code>标签(对应<code>DOMContentLoaded</code>结束)的这段时间就是白屏时间。</p>
<p>计算方式：<code>DOMContentLoadedEventEnd - fetchStart</code></p>
<p><strong>首屏时间：</strong></p>
<p>从输入 URL 到浏览器中当前视口的内容渲染完毕，呈现出具体画面的这段时间就是首屏时间。</p>
<p>计算方式：参考<a target="_blank" rel="noopener" href="https://github.com/iyjhabc/first-meaningful-paint/blob/master/src/index.js">阿里ARMS</a>，使用ARMS的计算方法，将可见dom元素数量增长最快的时间点作为首屏时间。</p>
</li>
</ol>
<h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h3><h4 id="考点1：事件与事件流"><a href="#考点1：事件与事件流" class="headerlink" title="考点1：事件与事件流"></a>考点1：事件与事件流</h4><ol>
<li><p><strong>什么是事件？什么是事件流？</strong></p>
<p>JS 和 html 之间的交互是通过事件实现的。事件就是用户或浏览器执行的某种操作，比如鼠标点击、移入移出。</p>
<p>当事件发生时，浏览器会创建一个事件对象 <code>event</code>，并将详细信息放入其中，作为参数传递给事件处理程序。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Click me<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>elem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  elem<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 显示事件类型、元素和点击的坐标</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type <span class="token operator">+</span> <span class="token string">" at "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>currentTarget<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"Coordinates: "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>clientX <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> event<span class="token punctuation">.</span>clientY<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre>

<p>DOM 结构是一个以 document 为根节点的多叉树。当一个 html 元素产生事件时，该事件会在该元素节点与根节点之间传播，在其经过的路径上所有节点都会接收到该事件，这个传播过程就是 DOM 事件流。事件流描述的是从页面中接收事件的顺序。</p>
</li>
</ol>
<h4 id="考点2：事件模型"><a href="#考点2：事件模型" class="headerlink" title="考点2：事件模型"></a>考点2：事件模型</h4><ol>
<li><p><strong>事件模型有哪几种？</strong></p>
<p>事件模型可以分为三种：</p>
<ul>
<li>原始事件模型（DOM0级）</li>
<li>标准事件模型（DOM2级）</li>
<li>IE事件模型（基本不用）</li>
</ul>
<hr>
<p><strong>原始事件模型：</strong></p>
<p>事件绑定监听函数比较简单，有两种方式：</p>
<ul>
<li>HTML代码中直接绑定</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">"fun()"</span><span class="token operator">></span></code></pre>

<ul>
<li>通过<code>JS</code>代码绑定</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'.btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> fun<span class="token punctuation">;</span></code></pre>

<p>特性：</p>
<ul>
<li>绑定速度快</li>
</ul>
<p><code>DOM0</code>级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行。</p>
<ul>
<li>只支持冒泡，不支持捕获</li>
<li>同一个类型的事件只能绑定一次</li>
</ul>
<hr>
<p><strong>标准事件模型：</strong></p>
<p>一个事件分三个阶段：</p>
<ul>
<li>事件捕获阶段：事件从<code>document</code>一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。(很少被使用)</li>
<li>事件处理阶段：事件到达目标元素，触发目标元素的监听函数。</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ul>
<p><strong>事件捕获：</strong></p>
<p>使用 <code>on&lt;event&gt;</code> 属性或使用 HTML 特性（attribute）或使用两个参数的 <code>addEventListener(event, handler)</code> 添加的处理程序，对捕获一无所知，它们仅在第二阶段和第三阶段运行。</p>
<p>为了在捕获阶段捕获事件，我们需要将处理程序的 <code>capture</code> 选项设置为 <code>true</code>：</p>
<pre class="language-js" data-language="js"><code class="language-js">elem<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>capture<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token comment">// 或者，用 &#123;capture: true&#125; 的别名 "true"</span>
elem<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span></code></pre>

<p><code>capture</code> 选项有两个可能的值：</p>
<ul>
<li>如果为 <code>false</code>（默认值），则在冒泡阶段设置处理程序。</li>
<li>如果为 <code>true</code>，则在捕获阶段设置处理程序。</li>
</ul>
<p><strong>事件处理：</strong></p>
<p>引发事件的那个嵌套层级最深的元素被称为目标元素，可以通过 <code>event.target</code> 访问。</p>
<p><strong>事件冒泡：</strong></p>
<p>当一个事件发生在一个元素上，将会从目标元素冒泡到<code>document</code>。它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。父元素上的处理程序始终可以获取事件实际发生位置的详细信息。</p>
<p>通常，它会一直上升到 <code>&lt;html&gt;</code>，然后再到 <code>document</code> 对象，有些事件甚至会到达 <code>window</code>，它们会调用路径上所有的处理程序。</p>
<p>但是任意处理程序都可以决定事件已经被完全处理，并停止冒泡。</p>
<p>用于停止冒泡的方法是 <code>event.stopPropagation()</code>。</p>
<blockquote>
<p>如果一个元素在一个事件上有多个处理程序，即使其中一个停止冒泡，其他处理程序仍会执行。</p>
<p>有一个 <code>event.stopImmediatePropagation()</code> 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行。</p>
</blockquote>
<hr>
<p><strong>IE事件模型：</strong></p>
<p>共有两个过程:</p>
<ul>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
</li>
<li><p><strong>解释下什么是事件委托？应用场景？</strong></p>
<p>事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown……）的处理委托给另一个元素。</p>
<p>事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素。当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件，然后在外层元素上去执行函数。父元素可以通过 <code>event.target</code> 访问目标元素。</p>
<p>优点：</p>
<ul>
<li>简化初始化并节省内存：无需添加许多处理程序。</li>
<li>更少的代码：添加或移除元素时，无需添加/移除处理程序。</li>
<li>DOM 修改 ：我们可以使用 innerHTML 等，来批量添加/移除元素。</li>
</ul>
<p>局限性：</p>
<ul>
<li>首先，事件必须冒泡。而有些事件不会冒泡(<code>focus</code>、<code>blur</code>)。此外，低级别的处理程序不应该使用 <code>event.stopPropagation()</code>。</li>
<li>其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。<code>mousemove</code>、<code>mouseout</code> 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</li>
</ul>
<hr>
<p><strong>应用场景：</strong></p>
<p>如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件，如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的。这时候就可以事件委托，把点击事件绑定在父级元素<code>ul</code>上面，然后执行事件的时候再去匹配目标元素。</p>
<p>还有一种场景是上述列表项并不多，我们给每个列表项都绑定了事件，但是如果用户能够随时动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的。</p>
</li>
</ol>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><h3 id="BOM-概念"><a href="#BOM-概念" class="headerlink" title="BOM 概念"></a>BOM 概念</h3><h4 id="考点1：BOM-与-DOM"><a href="#考点1：BOM-与-DOM" class="headerlink" title="考点1：BOM 与 DOM"></a>考点1：BOM 与 DOM</h4><ol>
<li><p><strong>说说你对 BOM 的理解？</strong></p>
<p><code>BOM(Browser Object Model)</code>，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象。</p>
<p>其作用就是和浏览器进行一些交互操作。如前进后退、滚动条上下滚动、刷新、浏览器窗口变化，以及获取客户的一些信息如：浏览器版本，屏幕分辨率。</p>
<p>浏览器的全部内容可以看成<code>DOM</code>，而整个浏览器可以看成<code>BOM</code>。<code>DOM</code> 的顶级对象是 <code>document</code>，而<code>BOM</code> 的顶级对象是 <code>window</code>。</p>
</li>
</ol>
<h4 id="考点2：页面生命周期"><a href="#考点2：页面生命周期" class="headerlink" title="考点2：页面生命周期"></a>考点2：页面生命周期</h4><ol>
<li><p><strong>说说 HTML 页面的生命周期？</strong></p>
<p>HTML 页面的生命周期包含三个重要事件：</p>
<ul>
<li><code>DOMContentLoaded</code> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li>
<li><code>load</code> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li>
<li><code>beforeunload/unload</code> —— 当用户正在离开页面时。</li>
</ul>
<hr>
<p><code>DOMContentLoaded</code> 事件：</p>
<p><strong>触发时机：</strong></p>
<p>发生在 <code>document</code> 对象上。在 DOM 树构建完毕后，就会触发此事件，此时页面只包含基本的 DOM 结构。</p>
<p>当浏览器处理一个 HTML 文档，并在文档中遇到 <code>&lt;script&gt;</code> 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 <code>document.write</code> 操作，所以 <code>DOMContentLoaded</code> 必须等待脚本执行结束。外部样式表不会影响 DOM，因此 <code>DOMContentLoaded</code> 不会等待它们。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">function</span> <span class="token function">ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'DOM is ready'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 图片目前尚未加载完成（除非已经被缓存），所以图片的大小为 0x0</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Image size: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>img<span class="token punctuation">.</span>offsetWidth<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">x</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>img<span class="token punctuation">.</span>offsetHeight<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"DOMContentLoaded"</span><span class="token punctuation">,</span> ready<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>

<p>但如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>style.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  <span class="token comment">// 在样式表加载完成之前，脚本都不会执行</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">getComputedStyle</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">.</span>marginTop<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre>

<p>当 <code>DOMContentLoaded</code> 等待脚本时，它现在也在等待脚本前面的样式。</p>
<p><strong>常见的应用场景：</strong></p>
<p>Firefox，Chrome 和 Opera 都会在 <code>DOMContentLoaded</code> 中自动填充表单。</p>
<hr>
<p><code>load</code>事件：</p>
<p><strong>触发时机：</strong></p>
<p>当整个页面的资源(包括图片、样式和其他资源)都加载完毕时，会触发 window 对象上的 load 事件。可以通过 <code>onload</code> 属性获取此事件。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
  window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 与此相同 window.addEventListener('load', (event) => &#123;</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Page loaded'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 此时图片已经加载完成</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Image size: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>img<span class="token punctuation">.</span>offsetWidth<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">x</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>img<span class="token punctuation">.</span>offsetHeight<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>img<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>

<hr>
<p><code>beforeunload</code>事件：</p>
<p><strong>触发时机：</strong></p>
<p>如果访问者触发了离开页面的导航或试图关闭窗口，<code>beforeunload</code> 处理程序将要求进行更多确认。</p>
<p>如果我们要取消事件，浏览器会询问用户是否确定。</p>
<pre class="language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function-variable function">onbeforeunload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token string">"There are unsaved changes. Leave now?"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<hr>
<p><code>unload</code>事件：</p>
<p><strong>触发时机：</strong></p>
<p>当访问者离开页面时，<code>window</code> 对象上的 <code>unload</code> 事件就会被触发。我们可以在那里做一些不涉及延迟的操作，例如关闭相关的弹出窗口。</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> analyticsData <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 带有收集的数据的对象 */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"unload"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  navigator<span class="token punctuation">.</span><span class="token function">sendBeacon</span><span class="token punctuation">(</span><span class="token string">"/analytics"</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>analyticsData<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ol>
<h3 id="BOM-对象"><a href="#BOM-对象" class="headerlink" title="BOM 对象"></a>BOM 对象</h3><h4 id="考点1：Window-对象"><a href="#考点1：Window-对象" class="headerlink" title="考点1：Window 对象"></a>考点1：Window 对象</h4><ol>
<li><p><strong>怎么理解 window 对象？</strong></p>
<p><code>BOM</code> 的核心对象是<code>window</code>，它表示浏览器的一个实例。</p>
<p>在浏览器中，<code>window</code>对象有双重角色，即是浏览器窗口的一个接口，又是全局对象。</p>
<p>因此所有在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法。</p>
</li>
<li><p><strong>如何控制 window 窗口？</strong></p>
<p>关于窗口控制方法如下：</p>
<ul>
<li><code>moveBy(x,y)</code>：从当前位置水平移动窗体x个像素，垂直移动窗体y个像素，x为负数，将向左移动窗体，y为负数，将向上移动窗体</li>
<li><code>moveTo(x,y)</code>：移动窗体左上角到相对于屏幕左上角的(x,y)点</li>
<li><code>resizeBy(w,h)</code>：相对窗体当前的大小，宽度调整w个像素，高度调整h个像素。如果参数为负值，将缩小窗体，反之扩大窗体</li>
<li><code>resizeTo(w,h)</code>：把窗体宽度调整为w个像素，高度调整为h个像素</li>
<li><code>scrollTo(x,y)</code>：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置</li>
<li><code>scrollBy(x,y)</code>： 如果有滚动条，将横向滚动条向左移动x个像素，将纵向滚动条向下移动y个像素</li>
</ul>
<p><code>window.open()</code> 既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口</p>
<p>如果 <code>window.open()</code> 传递了第二个参数，且该参数是已有窗口或者框架的名称，那么就会在目标窗口加载第一个参数指定的URL</p>
<pre class="language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'htttp://www.vue3js.cn'</span><span class="token punctuation">,</span><span class="token string">'topFrame'</span><span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span> <span class="token operator">&lt;</span> a href<span class="token operator">=</span><span class="token string">" "</span> target<span class="token operator">=</span><span class="token string">"topFrame"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span> a<span class="token operator">></span></code></pre>

<p><code>window.open()</code> 会返回新窗口的引用，也就是新窗口的 <code>window</code> 对象</p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> myWin <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'http://www.vue3js.cn'</span><span class="token punctuation">,</span><span class="token string">'myWin'</span><span class="token punctuation">)</span></code></pre>

<p><code>window.close()</code> 仅用于通过 <code>window.open()</code> 打开的窗口</p>
<p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，该属性指向打开他的原始窗口对象</p>
</li>
</ol>
<h4 id="考点2：Location-对象"><a href="#考点2：Location-对象" class="headerlink" title="考点2：Location 对象"></a>考点2：Location 对象</h4><ol>
<li><p><strong>什么是 location 对象？有什么作用？</strong></p>
<p>Location 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 <code>window.location</code> 和 <code>document.location</code> 属性，可以拿到这个对象。</p>
<p><code>location</code>属性描述如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>hash</td>
<td>“#contents”</td>
<td>url中#后面的字符，没有则返回空串</td>
</tr>
<tr>
<td>host</td>
<td><a target="_blank" rel="noopener" href="http://www.wrox.com/">www.wrox.com:80</a></td>
<td>服务器名称和端口号</td>
</tr>
<tr>
<td>hostname</td>
<td><a target="_blank" rel="noopener" href="http://www.wrox.com/">www.wrox.com</a></td>
<td>域名，不带端口号</td>
</tr>
<tr>
<td>href</td>
<td><a target="_blank" rel="noopener" href="http://www.wrox.com/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td>
<td>完整url</td>
</tr>
<tr>
<td>pathname</td>
<td>“/WileyCDA/“</td>
<td>服务器下面的文件路径</td>
</tr>
<tr>
<td>port</td>
<td>80</td>
<td>url的端口号，没有则为空</td>
</tr>
<tr>
<td>protocol</td>
<td>http:</td>
<td>使用的协议</td>
</tr>
<tr>
<td>search</td>
<td>?q=javascript</td>
<td>url的查询字符串，通常为？后面的内容</td>
</tr>
</tbody></table>
<p>除了 <code>hash</code>之外，只要修改<code>location</code>的一个属性，就会导致页面重新加载新<code>URL</code></p>
<p><code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载</p>
<p>如果要强制从服务器中重新加载，传递一个参数<code>true</code>即可</p>
</li>
</ol>
<h4 id="考点3：History-对象"><a href="#考点3：History-对象" class="headerlink" title="考点3：History 对象"></a>考点3：History 对象</h4><ol>
<li><p><strong>什么是 history 对象？有什么作用？</strong></p>
<p><code>history</code>对象主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转。</p>
<p>常用的属性如下：</p>
<ul>
<li><code>history.go()</code></li>
</ul>
<p>接收一个整数数字或者字符串参数：向最近的一个记录中包含指定字符串的页面跳转</p>
<pre class="language-js" data-language="js"><code class="language-js">history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token string">'xxx.com'</span><span class="token punctuation">)</span></code></pre>

<p>当参数为整数数字的时候，正数表示向前跳转指定的页面，负数为向后跳转指定的页面</p>
<pre class="language-js" data-language="js"><code class="language-js">history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">//向前跳转三个记录</span>
history<span class="token punctuation">.</span><span class="token function">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//向后跳转一个记录</span></code></pre>

<ul>
<li><code>history.forward()</code>：向前跳转一个页面</li>
<li><code>history.back()</code>：向后跳转一个页面</li>
<li><code>history.length</code>：获取历史记录数</li>
</ul>
</li>
<li><p><strong>了解过 vue-router 吗？history 模式和 hash 模式有什么区别？</strong></p>
<p><strong>hash 模式：</strong></p>
<p>形式上：hash 模式 url 里面永远带着 <code>#</code> 号，开发当中默认使用这个模式。</p>
<p>本质是一个浏览器内置的发布订阅，改变 hash 会广播到<code>onhashchange</code>事件，可以在window对象上监听这个事件：</p>
<pre class="language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>oldURL<span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
     document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">.</span>color <span class="token operator">=</span> hash<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>每次 hash 发生变化，新旧 url 都会被记录下来，从而可以实现前进后退操作。</p>
<p><strong>history 模式：</strong></p>
<p>原理是利用了 history 对象的 API。其中比较重要的两个是 <code>pushState</code> 和 <code>replaceState</code>。</p>
<p>history 不是依靠 url 改变来切换路由的，因为 hash 不变的情况下 url 改变不会触发任何事件，所以需要依赖内部实现的发布订阅模式，通知相应的组件。并且这个过程需要实现持久化存储，保证在刷新之后还能停留在当前路由。</p>
<p>使用 history 模式，如果直接输入 URL 回车或者刷新是会发送真实请求的。因此在服务端需要配置重定向返回 <code>index</code>，再由前端处理路由匹配。</p>
</li>
</ol>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>sticla</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://blog.sticla.top/2021/08/13/front-end-interview-review-js-web-api/" title="备战前端面试--js-web-api篇">https://blog.sticla.top/2021/08/13/front-end-interview-review-js-web-api/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/08/14/class-and-this/" rel="prev" title="Class 子类没有 this？ Class 真的只是语法糖吗？"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Class 子类没有 this？ Class 真的只是语法糖吗？</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/08/12/front-end-interview-review-js/" rel="next" title="备战前端面试--js基础篇"><span class="post-nav-text">备战前端面试--js基础篇</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/li-sticla/li-sticla.github.io/issues?q=is:issue+备战前端面试--js-web-api篇">GitHub Issues</a></div><div id="valine-container"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js", () => {
  const valineConfig = {"enable":true,"appId":"fhhkJbCVeplMMyPTL5CmiGOV-MdYXbMMI","appKey":"gXz6Ktd45hdMO77EYNY9cRds","placeholder":"有任何问题请留言，看到会回复滴","avatar":null,"pageSize":10,"visitor":true,"highlight":true,"recordIP":false,"enableQQ":true,"avatar_cdn":"https://gravatar.loli.net/avatar/","meta":["nick","mail","link"],"el":"#valine-container","lang":"en"}
  valineConfig.path = "/2021/08/13/front-end-interview-review-js-web-api/"
  new Valine(valineConfig)
}, window.Valine);</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> sticla</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.2</span></div><div class="live_time"><span>本博客已萌萌哒地存活了</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-03-19T21:17:49');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#6200ee" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>